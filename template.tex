\documentclass[14pt, a4paper]{extreport}

\linespread{1.5}

\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{titlesec}
\usepackage[centertags]{amsmath}
\usepackage{amsthm,amsfonts,amssymb}
\usepackage{indentfirst}
\usepackage{csquotes}

\usepackage{extsizes}
\usepackage[left=25mm,right=10mm,top=20mm,bottom=20mm,bindingoffset=0cm]{geometry}

\usepackage{cmap}
\usepackage{multirow}
\usepackage{float}
\usepackage{mathtools}
\DeclarePairedDelimiter\ceil{\lceil}{\rceil}
\DeclarePairedDelimiter\floor{\lfloor}{\rfloor}


%\usepackage{pscyr}
\RequirePackage{graphicx}
\RequirePackage{subfig}
\usepackage{thmtools}   
\usepackage{hyperref}
\usepackage[nameinlink]{cleveref}


\newtheorem{lemma}{\indent Лемма}
\newtheorem{theorem}{\indent Теорема}
\newtheorem{corollary}{\indent Следствие}
\newtheorem{problem}{\indent Задача}
\newtheorem{remark}{\indent Замечание}
\newtheorem{definition}{\indent Определение}
\newtheorem{proposition}{\indent Утверждение}
\newtheorem{example}{\indent Пример}
\newtheorem{notation}{\indent Обозначение}

\crefname{lemma}{л.}{л.}
\crefname{theorem}{теор.}{теор.}
\crefname{corollary}{след.}{след.}
\crefname{definition}{опр.}{опр.}
\crefname{proposition}{утв.}{утв.}
\crefname{example}{прим.}{прим.}
\crefname{notation}{обозн.}{обозн.}
\crefname{remark}{замеч.}{замеч.}

\crefname{theorem}{Теорема}{Теорема}
\newcommand{\order}[2]{#1_{(#2)}}

\newcommand{\T}{^{\text{\tiny\sffamily\upshape\mdseries T}}}

\graphicspath{{./img/}}


\def\XYtext(#1,#2)#3{\rlap{\kern#1\lower-#2\hbox{#3}}}
\newcommand{\word}{\{0, 1\}^*}
\newcommand{\defeq}{\overset{\underset{\mathrm{def}}{}}{=}}
\newcommand{\poly}{\textit{poly}}
\newcommand{\pr}[2]{\textbf{Pr}_{#1}\left(#2\right)}
\newcommand{\set}[1]{\left\{#1\right\}}

% Переопределение вставки графики
\newcounter{PictureNo}

\hyphenpenalty 100
\tolerance 10000


\newenvironment{Proof}%
    {\par\noindent{\bf Доказательство.}}%
    {\hfill$\scriptstyle\blacksquare$}

\usepackage[
    backend=biber
]{biblatex}
\addbibresource{thesis.bib}

\addto\captionsenglish{\renewcommand{\figurename}{Рисунок}}
\addto\captionsenglish{\renewcommand{\tablename}{Таблица}}
\addto\captionsenglish{\renewcommand{\bibname}{Список использованных источников}}
\captionsetup[figure]{labelfont=footnotesize,textfont=footnotesize}
\captionsetup[table]{labelfont=footnotesize,textfont=footnotesize}

\addto\captionsenglish{\renewcommand{\proofname}{Доказательство}}

\makeatletter % эта строка НЕОБХОДИМА!
\renewcommand{\@chapapp}{Глава} 
\addto\captionsenglish{% Replace "english" with the language you use
  \renewcommand{\contentsname}%
    {Оглавление}%
}

\titleformat{\chapter}[display]
{\normalfont\bfseries\center}
{Глава \thechapter. }{0em}{}

\titleformat{\section}[block]
{\normalfont\bfseries\center}
{\thesection. }{0em}{}

\begin{document}
\begin{center}
\hfill \break
\footnotesize{Федеральное государственное автономное образовательное учреждение 
высшего образования}\\ 
\small{\textbf{<<Московский физико-технический институт (государственный университет)>>}}\\
\hfill \break
\normalsize{Факультет инноваций и высоких технологий}\\
\normalsize{Кафедра дискретной математики}\\
\end{center}
\footnotesize{\textbf{Направление подготовки:} 03.03.01 Прикладные математика и физика}\\
\hfill \break
\hfill \break
\hfill \break
\hfill \break
\begin{center}
\large{\textbf{Рациональные интерактивные доказательства}}\\
\normalsize{Бакалаврская работа}\\
\hfill \break
\hfill \break
\end{center}
 
\hfill \break
 
\begin{flushright}
\footnotesize{ 
\begin{tabular}{rl}
\textbf{Обучающийся:} & Зинов Николай Александрович \\
 & \underline{\hspace{3cm}} \\\\
\textbf{Научный руководитель:} & к. ф.-м. н., \\
            & Д. В. Мусатов \\
 & \underline{\hspace{3cm}} \\\\
\end{tabular}
}
\end{flushright}

\hfill \break
\hfill \break
\hfill \break
\hfill \break
\hfill \break
\hfill \break
\begin{center} Москва 2018 \end{center}
\thispagestyle{empty} % выключаем отображение номера для этой страницы
 
% КОНЕЦ ТИТУЛЬНОГО ЛИСТА
 
\newpage
\normalsize

\chapter*{Аннотация}
В данной работе исследуется недавно появивщаяся отрасль теории интеративных доказательств --- рациональные интерактивные доказательства с несколкими пруверами и ставится задача определение вычислительной силы означенных доказательств в случае снятия ограничения на взаимодействие между пруверами. Показывается, что такая система имеет не меньшую вычислительную силу, чем исходная. Помимо теоретической ценности предложенный протокол представляет интерес в приложении к системам облачных вычислений и криптовалют.
\tableofcontents{}
\chapter*{Введение}
Концепция интерактивных доказательств в теории сложности вычислений была предложена достаточно давно Babai и Moran \cite{babai1988arthur} и Goldwasser, Micali и Rackoff \cite{goldwasser1989ip}. Данная концепция состоит в том, чтобы рассматривать взаимодействие двух сторон: Верификатора (или Артура) и Прувера (Мерлина, далее в этой работе будет использоваться терминология верификатор-прувер). Верификатор вычислительно ограничен и может использовать только те функции, которые вычислимы на детерминированной машине Тьюринга за полиномиальное время. Однако, он может обмениваться информацией с вычислительно неограниченным Прувером. Ставится задача определения класса (обозначаемого $\textbf{IP}$) задач, для которых существуют протоколы, позволяющие Верификатору, с помощью взаимодействия с Прувером, получить ответ и убедиться в его правильности даже в том случае, если Прувер не является честным, то есть может пытаться отклониться от протокола с целью ввести Верификатора в заблуждение. Формальные определения описываемых классов даны ниже в главе 2.

Для понимания данной работы также необходимо особо отметить концепцию доказательств с несколькими пруверами. В ней Верификатор может общаться не с одним, а со многими вычислительно неограниченными пруверами, которые не могут общаться между собой, что дает Верификатору возможность сверять между собой ответы пруверов и таким образом решать задачи более сложные, чем позволяют стандартные интерактивные доказательства. Полная характеризация этого класса задач дана Babai, Fortnow и Lund \cite{babai1991mip}.

В последнее время интерес к теме интерактивных доказательств усилился в связи с появлением различных платформ для облачных вычислений, которые по сути являются системой делегации вычислений. Сторона с ограниченными вычислительными возможностями (клиент облачного провайдера) использует вычислительные мощности второй стороны (сервера в вычислительном облаке) для решения своих задач. Однако, на данный момент пользователи облачных сервисов полагаются на то, что провайдер производит вычисления верно, а не, например, генерирует ответы случайным образом. При текущем положении вещей, когда услуги по предоставлению вычислительных мощностей оказывают крупные компании, такие как Amazon и Google, косвенным подтверждением честности проводимых вычислений может служить репутация компании. Использование свободных вычислительных мощностей персональных компьютеров успено производится, например, в рамках проекта BOINC \cite{anderson2004boinc} для таких задач, как поиск больших простых чисел, однако каждое найденное число независимо проверяется для исключения обмана. Внедрение практических методов проверяемой делегации вычислений (verifiable delegation of computations), то есть протоколов, позволяющих заказчику вычисления эффективно проверять корректность его результата, позволит использовать подобные BOINC схемы для прикладных вычислений.

Другой областью приложения интерактивных доказательств в ближайшем будущем могут стать криптовалюты. Безопасность наиболее популярной системы --- Bitcoin, а также большинства других основана на концепции proof of work \cite{nakamoto2008bitcoin}. Суть метода состоит в том, что пользователи системы должны проводить затратные вычисления и приводить подтверждения факта их проведения. Интерактивные доказательства могут дать способ заменить в этом качестве бесполезные вычисления на решение прикладных задач.

В свете описанных приложений, Azar и Micali \cite{azar2012rational} предложили концепцию рациональных доказательств, где Верификатор по итогам общения с Прувером выплачивает ему награду, размер которой известным образом зависит от ответов Прувера. Требование того, чтобы Прувер не мог обмануть Верификатора заменяется требованием рациональности: для максимизации ожидаемой награды Пруверу наиболее выгодно отвечать честно.

В ходе развития идеи рациональных доказательств Chen, McCauley и Singh получили характеризации классов рациональных доказательств с несколькими пруверами --- как в модели, где пруверы максимизируют общую награду \cite{chen2016mrip}, так и в модели, где каждый прувер максимизирует свою индивидуальную награду \cite{chen2017noncoop}.

В выбранной ими постановке задачи предполагается, как и в \cite{babai1991mip}, что пруверы не могут общаться между собой. В классических интерактивных доказательствах это требование является существенным. Действительно, если разрешить пруверам общаться между собой, то, в силу их неограниченности, общение с ними можно свести к общению с одним прувером. Однако в модели рациональных доказательств такое сведение не возможно: даже при том условии, что пруверам разрешено общаться, они могут воздерживаться от общения, если они поставлены в условия конкуренции, то есть когда пруверу не выгодно передавать какую-то информацию другому пруверу.

Целью данной работы является определение вычислительных возможностей рациональных доказательств с несколькими коммуницирующими пруверами.

Основным результатом является то, что рациональные доказательства с коммуницирующими пруверами являются не менее вычислительно мощными, чем доказательства с некоммуницирующими пруверами. Также стоит отметить, что приведенный в данной работе протокол рационального доказательства является технически более простым, чем предложенный в \cite{chen2017noncoop}, так как в отличие от последнего не использует классический протокол для класса $\textbf{MIP}$, в котором используются сложные техники, такие как multilinearity testing, а опирается на алгоритм ранее предложенный Feige, Uriel и Kilian \cite{feige1997refereed} в задаче игр с рефери (refereed games).
\chapter{Интерактивные доказательства}
\section{Основные определения}
Существуют разнообразные модели интерактивных доказательств. Ниже приведено, насколько это возможно, наиболее общее определение системы интерактивного доказательства. Конкретные модели получаются из него введением дополнительных условий на входные данные и вычислительные возможности верификатора и прувера.
\begin{definition}\label{ip_system}
    Системой интерактивных доказательств называется совукупность двух функций: $P: \word \longrightarrow \word$ --- прувера и $V: \word \longrightarrow \word \cup \{Y, N\}$ --- верификатора (запись $\word$ означает множество конечных слов из символов $0$ и $1$). Протоколом работы системы интерактивных доказательств на входе $x \in \word$, случайных битах верификатора $v \in \word$, случайных битах прувера $p \in \word$, общих случайных битах $\left\{c_i\right\}_{i=1}^{\infty}$ является последовательность слов, определяемая следующим образом (предполагается, что кортежи слов однозначно кодируются в слова):
    \begin{enumerate}
        \item $q_1 \defeq V(x, v, c_1)$
        \item $r_1 \defeq P(x, p, c_1, q_1)$
        \item $q_2 \defeq V(x, v, c_1, c_2, q_1, r_1)$
        \item $r_2 \defeq P(x, p, c_1, c_2, q_1, r_1, q_2)$\\
            \vdots
        \item [(2k-1).] $q_k \defeq V(x, v, c_1, \ldots, c_k, q_1, r_1, \ldots, q_{k-1}, r_{k-1})$
        \item [(2k).] $r_k \defeq P(x, p, c_1, \ldots, c_k, q_1, r_1, \ldots, r_{k-1}, q_k)$
    \end{enumerate}
    Построение протокола завершается при условии, что очередкое $q_k \in \{Y, N\}$. Если $q_k = Y$, то говорится, что данная система интерактивных доказательств принимает вход $x$, иначе, если $q_k = N$, то говорится, что система отвергает вход $x$.

    Результатом работы системы доказательств нызывается $q_k$ --- сообщение верификатора на последней строчке протокола. Результат работы системы $\langle V, P\rangle$ обозначается $V^{P}_{v, p, c_i}(x)$.
\end{definition}
При фиксированной модели интерактивных доказательств можно рассмотреть класс языков (подмножеств множества $\word$), разрешаемых этой системой с достаточно большой вероятностью. Здесь приводится определение классического класса $\textbf{IP}$, предложенного в \cite{goldwasser1989ip}.
\begin{definition}\label{ip}
    Классом $\textbf{IP}$ называется множество языков такое, что $L \in \textbf{IP}$ тогда и только тогда, когда существует система интерактивного доказательства $\langle V, P\rangle$ со случайными битами верификатора (без случайных битов прувера и общих случайных битов), удовлетворяющая следующим свойствам:
    \begin{enumerate}
        \item Верификатор полиномиально ограничен, то есть на каждом шаге протокола функция $V$ вычислима на детерменированной машине Тьюринга за время, не превосходящее $\poly(|x|)$.
        \item Для любого слова $x \in L$ и любых случайных битов интерактивное доказательство завершается за конечное число строчек протокола.
        \item Для любого слова $x \in L$ выполнено $\pr{v}{V^P_{v}(x) = Y} \geqslant \frac{2}{3}$
        \item Для любого слова $x \notin L$ и для любой функции $P'$ выполнено\\$\pr{v}{V^{P'}_{v}(x) = Y} \leq \frac{1}{3}$
    \end{enumerate}
\end{definition}
Также следует упомянуть другую классическую систему интерактивных доказательств --- игры Артура-Мерлина, в которых имеюются только общие случайные биты ($c_{i}$). Данная система предложена в \cite{babai1988arthur} и в данной работе далее рассматриваться не будет.
\section{Интерактивные доказательства с несколькими пруверами}
Обобщение определения на случай нескольких пруверов производится естественным оборазом: имееется не одна, а несколько функций-пруверов и на каждом шаге верификатор выбирает, кто из них будет ему отвечать. Формально это можно записать следующим образом.
\begin{definition}\label{mip_system}
    Системой интерактивных доказательств c $n$ пруверами называется совукупность функций: $P_i: \word \longrightarrow \word, i \in \set{1\ldots n}$ --- пруверов и $V: \word \longrightarrow \word \cup \{Y, N\} \times \set{1 \dots n}$ --- верификатора. Протоколом работы системы интерактивных доказательств на входе $x \in \word$, случайных битах верификатора $v \in \word$, случайных битах пруверов $\left\{p_i\in \word\right\}_{i=1}^{\infty}$ и общих случайных битах $\left\{c_i\in \word\right\}_{i=1}^{\infty}$ является последовательность слов, определяемая следующим образом:
    \begin{enumerate}
        \item $(q^{s_1}_1, s_1) \defeq V(x, v, c_1)$
        \item $r^{s_1}_1 \defeq P_{s_1}(s_1, x, p_{s_1}, c_1, q^{s_1}_1)$
        \item $(q^{s_2}_1, s_2) \defeq V(x, v, c_1, c_2, q^{s_1}_1, r^{s_1}_1)$
        \item $r^{s_2}_2 \defeq P_{s_2}(s_2, x, p_{s_2}, c_1, c_2, q^{s_2}_1)$\\
            \vdots
        \item[(2k-1).] $(q^{s_k}_l, s_k) \defeq V(x, v, c_1, \ldots, c_k, q^1_1, r^1_1, \ldots, q^1_{l_1-1}, r_{l_1-1}, \ldots, q^n_1, r^n_1, \ldots, q^n_{l_n-1}, r_{l_n-1})$
        \item[(2k).] $r^{s_k}_l \defeq P(s_k, x, p_{s_k}, c_1, \ldots, c_k, q^{s_k}_1, r^{s_k}_1, \ldots, r^{s_k}_{l-1}, q^{s_k}_l)$
    \end{enumerate}
    Аналогично случаю единственного прувера, построение протокола завершается при условии, что очередкое $q_k \in \{Y, N\}$. Если $q_k = Y$, то говорится, что данная система интерактивных доказательств принимает вход $x$, иначе, если $q_k = N$, то говорится, что система отвергает вход $x$.

    Результатом работы системы доказательств нызывается $q_k$ --- сообщение верификатора на последней строчке протокола. Результат работы системы $\langle V, P_1, \ldots, P_n\>$ обозначается $V^{P_1, \ldots, P_n}_{v, p_i, c_i}(x)$.
\end{definition}

Отдельно необходимо отметить, что в определенной выше системе пруверы не могут общаться между собой (в формальном определении это выражается в том, что функции $P_1, \dots, P_n$ не принимают дополнительных входов, кроме случайных бит и протокола своего прошлого общения с верификатором). Если разрешить пруверам общаться, то они могут передавать друг другу недостающие входные данные. Если дополнительно выбрать функции-пруверы были одинаковыми (объединить функции в одну, сделав разбор случая по аргументу $s$), то полученная система доказательств не будет отличаться от системы с одним прувером: вне зависимости от того, какого прувера выберет верификатор, его ответ вычисляется как фиксированная функция от всего протокола общения, где недостающие сообщения получены им от других пруверов. Таким образом полученная при удалении условия запрета на общение пруверов система доказательств обладает той же силой, что и система с одним прувером.

Аналогично классу $\textbf{IP}$ определяется класс $\textbf{MIP}$.

\begin{definition}\label{mip}
    Классом $\textbf{MIP}$ называется множество языков такое, что $L \in \textbf{MIP}$ тогда и только тогда, когда существует система интерактивного доказательства c несколькими пруверами $\langle V, P_1, \ldots, P_n\rangle$ со случайными битами верификатора (без случайных битов пруверов и общих случайных битов), удовлетворяющая следующим свойствам:
    \begin{enumerate}
        \item Верификатор полиномиально ограничен, то есть на каждом шаге протокола функция $V$ вычислима на детерменированной машине Тьюринга за время, не превосходящее $\poly(|x|)$.
        \item Для любого слова $x \in L$ и любых случайных битов интерактивное доказательство завершается за конечное число строчек протокола.
        \item Для любого слова $x \in L$ выполнено $\pr{v}{V^{P_1, \ldots, P_n}_{v}(x) = Y} \geqslant\frac{2}{3}$
        \item Для любого слова $x \notin L$ и для любых функций $P'_1, \ldots, P'_n$ выполнено\\$\pr{v}{V^{P_1, \ldots, P_n}_{v}(x) = Y} \leq \frac{1}{3}$
    \end{enumerate}
\end{definition}
\section{Характеризации классов $\textbf{IP}$ и $\textbf{MIP}$}
Под характеризацией сложностного класса языков понимается нахождение определенного сложного класса понимается нахождение иным образом определенного класса, равного ему. Обычно характеризация проводится с помошью классов языков, вычислимых на детерминированных и недетерминированных машинах Тьюринга с определенным ограничением времени или памяти. Для классов интерактивных доказательств справедливы следующие характеризации.
\begin{theorem}$\textbf{IP} = \textbf{PSPACE}$, то есть класс интерактивных доказательств совпадает с классом языков, разрешимых детерминированной машиной Тьюринга с использованием полиномиальной памяти. \cite{shamir1992ip}
\end{theorem}
\begin{theorem}$\textbf{MIP} = \textbf{NEXP}$, то есть класс интерактивных доказательств с несколькими пруверами совпадает с классом языков, разрешимых недетерминированной машиной Тьюринга за экспоненциальное время \cite{babai1991mip}\end{theorem}

\chapter{Рациональные доказательства}
\section{Основная концепция}
В определенной выше модели интерактивных доказательств требуется, чтобы с большой вероятностью прувер получил правильный ответ даже, если прувер пытается его обмануть. Данное требование влечет за собой необходимость верификатору проверять ответы прувера на корректность. В концепции рациональных доказательств предлагается считать пруверов рациональными, то есть всегда действующими для максимизации своей ожидаемой награды. Награда назначается верификатором по результатам общения с прувером по наперед известному всем пруверам правилу. 

Приведем определение системы рациональных интерактивных доказательств сразу для случая нескольких пруверов.
\begin{definition}
    Системой рациональных интерактивных доказательств c $n$ пруверами называется совокупность функций: $P_i: \word \longrightarrow \word, i \in \set{1\ldots n}$ --- пруверов, $R_i: \word \longrightarrow \mathbb{R}$ --- наград пруверов и $V: \word \longrightarrow \word \cup \{Y, N\} \times \set{1 \dots n}$ --- верификатора. Протоколом работы системы интерактивных доказательств на входе $x \in \word$, случайных битах верификатора $v \in \word$, случайных битах пруверов $\left\{p_i\in \word\right\}_{i=1}^{\infty}$ и общих случайных битах $\left\{c_i\in \word\right\}_{i=1}^{\infty}$ является последовательность слов, определяемая следующим образом:
    \begin{enumerate}
        \item $(q^{s_1}_1, s_1) \defeq V(x, v, c_1)$
        \item $r^{s_1}_1 \defeq P_{s_1}(s_1, x, p_{s_1}, c_1, q^{s_1}_1)$
        \item $(q^{s_2}_1, s_2) \defeq V(x, v, c_1, c_2, q^{s_1}_1, r^{s_1}_1)$
        \item $r^{s_2}_2 \defeq P_{s_2}(s_2, x, p_{s_2}, c_1, c_2, q^{s_2}_1)$\\
            \vdots
        \item $(q^{s_k}_l, s_k) \defeq V(x, v, c_1, \ldots, c_k, q^1_1, r^1_1, \ldots, q^1_{l_1-1}, r_{l_1-1}, \ldots, q^n_1, r^n_1, \ldots, q^n_{l_n-1}, r_{l_n-1})$
        \item $r^{s_k}_l \defeq P(s_k, x, p_{s_k}, c_1, \ldots, c_k, q^{s_k}_1, r^{s_k}_1, \ldots, r^{s_k}_{l-1}, q^{s_k}_l)$
    \end{enumerate}
    Построение протокола завершается при условии, что очередкое $q_k \in \{Y, N\}$. Если $q_k = Y$, то говорится, что данная система рациональныъ интерактивных доказательств принимает вход $x$, иначе, если $q_k = N$, то говорится, что система отвергает вход $x$.

    Результатом работы системы доказательств нызывается $q_k$ --- сообщение верификатора на последней строчке протокола. Результат работы системы $\langle V, P_1, \ldots, P_n, R_1, \ldots, R_n\rangle$ обозначается $V^{P_1, \ldots, P_n, R_1, \ldots, R_n}_{v, p_i, c_i}(x)$.
\end{definition}

В случае одного прувера формализация того, что он максимизирует свою награду производится простым образом и получается следующее определение.
\begin{definition}\label{rip}
    Классом $\textbf{RIP}$ называется множество языков такое, что $L \in \textbf{RIP}$ тогда и только тогда, когда существует система рационального интерактивного доказательства $\langle V, P, R\rangle$ со случайными битами верификатора (без случайных битов прувера и общих случайных битов), удовлетворяющая следующим свойствам:
    \begin{enumerate}
        \item Верификатор полиномиально ограничен, то есть на каждом шаге протокола функция $V$, а также $R(Q(V, P))$, где $Q$ --- протокол работы, вычислима на детерминированной машине Тьюринга за время, не превосходящее $\poly(|x|)$.
        \item Если $P = \textbf{argmax}_{P'} \mathbb{E}_v R(Q(V, P'))$, то $\forall x: x \in L \iff V^{P, R}_{v}(x) = Y$
        \end{enumerate}
    \end{definition}

    \section{Понятие utility gap}

    Условие, состоящее в том, что прувер всегда максимизирует свою награду, является очень сильным. Действительно, оно заставляет его действовать честно даже в том случае, если обман привел бы лишь к незначительному уменьшению награды. Более естественное условие получается, если требовать, чтобы нечестное поведение прувера уменьшало его награду не менее, чем на заранее определенную величину, что дает следующее определение.

    \begin{definition}
        Классом рациональных интерактивных доказательств с utility gap $f(n)$ ($\textbf{f(n)-RIP}$) называется множество языков такое, что $L \in \textbf{RIP}$ тогда и только тогда, когда существует система рационального интерактивного доказательства $\langle V, P, R\rangle$ со случайными битами верификатора (без случайных битов прувера и общих случайных битов), удовлетворяющая следующим свойствам:
        \begin{enumerate}
            \item Верификатор полиномиально ограничен, то есть на каждом шаге протокола функция $V$, а также $R(Q(V, P, x, v))$, где $Q$ --- протокол работы, вычислима на детерминированной машине Тьюринга за время, не превосходящее $\poly(|x|)$.
            \item Если $\forall x: \mathbb{E}_v R(Q(V, P, x, v)) \geqslant \textbf{max}_{P'} \mathbb{E}_v R(Q(V, P', x, v)) - \frac{1}{f(|x|)}$, то $\forall x: x \in L \iff V^{P, R}_{v}(x) = Y$
            \end{enumerate}
        \end{definition}

        Рассматривают константный ($f(n) = \text{const}$), значительный ($f(n) = \textit{poly}(n)$) и незначительный ($f(n) = \textit{exp}(n)$) зазор.

        \chapter{Случай нескольких пруверов}
        В случае наличия нескольких пруверов определение того, в чем состоит максимизация награды, усложняется. Причиной этого является то, что награда прувера зависит, в общем случае, не только от его действий, но и от действий других пруверов. Для описания поведения пруверов в такой модели используется аппарат теории игр. В ее терминах система рациональных интерактивных доказательств представляет из себя игру с неполной информацией и совершенной памятью в развернутой форме.

        Систему рациональных доказательств можно считать игрой, позицией в которой является полный протокл общения верификатора с пруверами на данный момент, а ходом является сообщение, которое прувер отправляет верификатору. Заметим, что поскольку прувер знает только те сообщения, которые верификатор отправляет ему, то полный протокол ему неизвестен, то есть он не знает текущую позицию.
        Рассмотрим множество всех протоколов, которые получаются из протокола общения верификатора с данным прувером заполнением пропусков всеми корректными с точки зрения алгоритма способами.
        Это \textit{информационное множество} содержит все возможные на текущий момент с точки зрения данного прувера позиции, однако какая именно из них реализуется ему неизвестно.
        В системе без случайных битов пруверов каждую функцию $P_i$ в обозначениях теории игр можно считать чистой стратегией: она принимает на вход прошлую историю общения верификатора с этим прувером (она задает информационное множество данного прувера) и возвращает ответ верификатору (действие). В случае наличия случайных битов пруверов имеем поведенческую стратегию: случайные биты прувера задают вероятностное распределение по действиям. Стратегическим профилем $s$ будем называть набор стратегий всех игроков.

        \section{Усиленное секвенциальное равновесие}

        Каждый прувер выбирает свою стратегию так, чтобы максимизировать свою награду исходя из стратегий остальных игроков.
        Их взаимная конкуренция приводит к тому, что стратегический профиль приходит к \textit{равновесию}. Определим концепцию решения, которая была предложена для рациональных доказательств Chen et al. в \cite{chen2017noncoop}.
        Следует отметить, что выбор конкретной концепции решения продиктован условиями доказательства верхней оценки на вычислительную мощность, что будет подробно описано ниже.

        Усиленное секвенциальное равновесие (strong sequential equilibrium) было предложенно как рафинация сильного секвенциального равновесия (в англоязычной литературе оно называется просто sequential equilibrium), предложенного Kreps и Wilson \cite{kreps1982sequential}.

        Назовем верой функцию $\mu$, задающую на каждом информационном множестве $I$ вероятностную меру: для каждой игровой позиции в $I$ она задает вероятность ее реализации по мнению игрока, чей ход в $I$. Естественным образом можно определить ожидаемый выигрыш данного игрока при заданном стратегическом профиле и вере. Наилучшей стратегией при вере $\mu$ будем называть такую стратегию, которая дает максимальный ожидаемый выигрыш при этой вере.
        \begin{definition}[Усиленное секвенциальное равновесие]
            Стратегический профиль $s$ является усиленным секвенциальным равновесием, если для каждого игрока $i$ и каждого информационного множества $I_i$ игрока $i$ выполнено:

            \begin{enumerate}
                \item Если информационное множество $I_i$ достижимо при данном стратегическом профиле (то есть оно реализуется с ненулевой вероятностью), то при условии, что достигнуто информационное множество $I_i$, стратегия игрока $i$ ($s_i$) является наилучшей при фиксированных стратегиях остальных игроков ($s_{-i}$) при вере игрока $i$, полученной из $s$ по правилу Байеса.
                \item Если же информационное множество $I_i$ недостижимо, то при условии того, что достигнуто $I_i$, стратегия $s_i$ является наилучшей против $s_{-i}$ при любой вере игрока $i$.
            \end{enumerate}
        \end{definition}

        Такое определение равновесие накладывает дополнительное условие на оптимальность стратегии в недостижимых информационных множествах. Поэтому, в отличие от секвенциального равновесия, оно существует не для всех игр в развернутой форме с совершенной памятью.

        \section{Рекурсивно-максимальное усиленное секвенциальное равновесие (УСР)}

        Несмотря на строгость условий усиленного секвенциального равновесия в игре может быть несколько равновесий. Чтобы формализовать тот факт, что среди всевозможных равновесий игроки по возможности выбирают то, где награды всех игроков максимальны, требуется дальнейшее уточнение понятия решения.

        Максимальное УСР можно ввести следующим образом: если при стратегиях $s$, являющихся УСР, ожидаемый выигрыш каждого игрока не меньше, чем при любом другом УСР $s'$, то $s$ является максимальным.

        Следуя \cite{chen2017noncoop} введем следующее определение, предложенное в \cite{kreps1982sequential}.
        \begin{definition}[Подформа]
            Пусть $I$ --- произвольное информационное множество. Обозначим $H_I$ --- множество всех возможных продолжений протоколов из $I$. $F_I$ --- множество информационных множеств, следующих за $I$, то есть всех информационных множеств, содержащих протоколы из $H_I$.

            $H_I$ является подформой на $I$, если для каждого $I' \in F_I$ все протоколы в нем являются продолжениями протоколов из $I$.

            Высотой подформы называется максимальное число ходов после достижения $I$. При заданной вере на $I$ выигрыш на подформе определяется, как ожидаемый выигрыш при начальной позиции распределенной согласно этой вере.
        \end{definition}

        Теперь можно определить понятие решения следующим образом.

        \begin{definition}[Рекурсивно-максимальное УСР]
            Стратегический профиль $s$ является рекурсивно-максимальным УСР тогда и только тогда, когда $s$ является УСР и выполнены следующие условия:
            \begin{itemize}
                \item Для каждой подформы $H_I$ высоты 1:
                    \begin{itemize}
                        \item Если $I$ достижимо при стратегиях $s$, то $s$ --- максимальное УСР относительно вер, полученных по правилу Байеса.
                        \item Если $I$ не является достижимым, то $s$ должно быть максимальным УСР относительно любых вер.
                    \end{itemize}
                \item Для каждой подформы $H_I$ высоты $>1$:
                    \begin{itemize}
                        \item Если $I$ достижимо при стратегиях $s$, то $s$ --- максимальное среди тех УСР, которые являются рекурсивно-максимальными УСР на всех подформах подформы $H_I$ (относительно вер, полученных по правилу Байеса).
                        \item Если $I$ недостижимо при стратегиях $s$, то $s$ --- максимальное среди тех УСР, которые являются рекурсивно-максимальными УСР на всех подформах подформы $H_I$ (относительно любых вер).
                    \end{itemize}
            \end{itemize}
        \end{definition}

        Теперь можно определить класс рациональных доказательств с несколькими пруверами:

        \begin{definition}
            Язык $L$ лежит в классе рациональных интерактивных доказательств с несколькими пруверами $\textbf{ncRIP}$ тогда и только тогда, когда существует такая система рациональных доказательств с несколькими пруверами, что в ней существет рекурсивно-максимальное УСР и при любом УСР результат работы равен $x \in L$ с вероятностью 1.
        \end{definition}

        Приведем характеризации класса $\textbf{ncRIP}$ с разным разрывом полезности, полученные Chen et al. 

        \begin{proposition}
            \begin{enumerate}
                \item $ O(1)-\textbf{ncRIP} = {\textbf{P}}^{\textbf{NEXP}[O(1)] } $
                \item $\textit{poly}(n)-\textbf{ncRIP} = \textbf{P}^{\textbf{NEXP}} $
                \item $\exp(n)-\textbf{ncRIP} = \textbf{EXP}^{\textbf{poly-NEXP}} $
            \end{enumerate}
        \end{proposition}
        \section{Utility gap в случае нескольких пруверов}


        \chapter{Случай коммуницирующих пруверов}

        В данной работе исследуется вариант рациональных доказательств с несколькими пруверами, в котором пруверы могут общаться между собой, то есть обмениваться строками произвольной длины. Сообщения передаются приватно между двумя пруверами, то есть ни остальные пруверы, ни верификатор не могут их прочесть. Можно доказать, что такой вариант имеет, как минимум, не меньшую вычислительную силу, чем обычный, то есть классы из утверждения выше допускают разрешения с помощью системы доказательств с коммуницирующими пруверами. Ниже будет приведен алгоритм рационального доказательства с коммуницирующими пруверами и константным разрывом полезности для произвольного языка из класса $\textbf{NEXP}$ и доказана его корректность. Затем на основе данного алгоритма будут построены доказательства для указанных выше языков.

        \section{Refereed games}
        Алгоритм для класса $\textbf{NEXP}$ приводимый ниже является модификацией алгоритма, предложенного Feige и Kilian \cite{feige1997refereed} в концепции игр с рефери (refereed games). Данная концепция развивалась независимо от рациональных доказательств, хотя фактически является частным случаем рациональных доказательств с несколькими пруверами.

        В игре участвуют два вычислительно неограниченных игрока и полиномиально ограниченный рефери. Рефери обменивается сообщениями с игроками и согласно фиксированному алгоритму (быть может, рандомизированному частными случайными битами рефери) выбирает одного из игроков победителем. Цель каждого из игроков --- выиграть. Для фиксированного класса языков ставится задача построения такого алгоритма рефери, при котором победивший игрок сообщает истинные сведения о принадлежности классу. С точки зрения рациональных доказательств игра с рефери является системой рациональных доказательств с двумя пруверами и нулевой суммой (то есть суммарный выигрыш равен $0$ при любом исходе игры).
        \section{Протокол рационального доказательства для класса $\textbf{NEXP}$}
        В данном разделе строится алгоритм рационального доказательства для произвольного языка из класса $\textbf{NEXP}$.
        \begin{definition}[Класс \textbf{NEXP}]Язык $L$ принадлежит классу $\textbf{NEXP}$ тогда и только тогда, когда существует такая недетерминированная машина Тьюринга, что $\forall x \in \word$ машина останавливается на входе $x$ за время $\exp(|x|)$ и принимает $x$ тогда и только тогда, когда $x \in L$.
        \end{definition}
        В приведенном определении фигурирует понятие машины Тьюринга. Посколько в дальнейших рассуждениях используются детали работы машины Тьюринга, приведем ее определение в том виде, который используется в этой работе.
        \begin{definition}Детерминированная машина Тьюринга состоит из ленты и считывающей головки. Лента состоит из ячеек, занумерованных натуральными числами и в каждой ячейке записан символ из конечного алфавита $A$, то есть состояние ленты может быть записано функцией $t: \mathbb{N} \longrightarrow A$. Считывающая головка на каждом шаге работы машины расположена над какой-то из ячеек ленты и находится в одном из конечного множества состояний $S$. На каждом шаге работы состояние машины изменяется согласно функции перехода, которая по символу в текущей ячейке и состоянию считывающей головки определяет, что записать с текущую ячейку и куда передвинуть головку (головка может сдвинуться на одну ячейку влево или вправо или остаться на месте). Формально функция перехода действует как $f: A \times S \longrightarrow A \times S \times \{L, N, R\}$.

            В начале выполнения работы входное слово $x$ записывается на ленте начиная с первой ячейки, а в оставшихся ячейках записывается специальный пустой символ $\emptyset$. Считывающая головка находится в специальном начальном состоянии над первой ячейкой. Если считывающая головка в процессе работы переходит в специальное терминальное состояние $\bot$, то считается, что она завершила работу. Если по завершении работы в первой ячейке находится символ $Y$, то говорится, что данная машина Тьюринга принимает вход $x$, иначе, что отвергает.
        \end{definition}
        \begin{definition}
            Недетерминированная машина Тьюринга отличается от детерминированной машины Тьюринга тем, что функция перехода $f$ может быть многозначной. В этом случае вычисление продолжается независимо из всех состояний, полученных функцией перехода. Таким образом образуется ориентированный граф вычислений, вершинами в котором являются полные состояния (ленты и головки), а дугами --- переходы. Машина принимает вход $x$, если существует путь из начального состояния в конечное, в котором в первой ячейке находится символ $Y$.
        \end{definition}

        Следует отметить, что в общем случае граф вычислений недетерминированной машины Тьюринга не является деревом: даже если вычисление пошло разными путями, они все еще могут привести к одному состоянию. Из технических соображений удобно рассмотреть следующую модификацию.

        \begin{definition}
            Недетерминированная машина Тьюринга с протоколированием дополнительно к основной ленте имеет дополнительную ленту протокола, на которую при каждом переходе записывается номер выбранного правила.
        \end{definition}

        Легко видеть, что при таком определении граф вычислений становится деревом. Заметим также, что а) описанная модификация не меняет результата работы машины Тьюринга, б) максимальное число возможных альтернативных переходов равно $3|A||S|$.

        Пусть дана недетерминированная машина Тьюринга с протоколированием $M$ для языка из класса \textbf{NEXP}. Рассмотрим систему рациональных доказательств с двумя пруверами: $P_1$ и $P_2$, которая позволяет верфикатору определить, принимает ли машина $M$ вход $x$. Обозначим $n = |x|$. В силу определения класса \textbf{NEXP}, на любом входе вычисление завершается за время не превосходящее $2 ^ n$, что означает, что считывающая головка никогда не покидает первых $2^n$ ячеек ленты. Таким образом протокол вычисления отдельно взятой ветви вычислений данной машины можно записать в виде $2^n$ строк длины $2^n$.

        Итак, задача верификатора состоит в том, чтобы определить, правда ли, что сущестует ветвь вычислений, которая приводит к принятию $x$. Рассмотрим определенную ветвь вычислений и, в духе игр с рефери, заставим $P_1$ доказывать, что данная ветвь вычислений завершается принятием входного слова, а $P_2$, что отвергает. На высоком уровне абстракции идея алгоритма состоит в том, что каждый из двух пруверов представляет свою версию протокола работы машины Тьюринга, а верификатор определяет, какая версия корректна. Начальное состояние фиксированно и известно верификатору, то есть пруверы должны быть согласны относительно него. Конечное состояние различно --- по версии $P_1$ в первой ячейке ленты находится символ $Y$, что противоречит версии прувера $P_2$. Значит, найдется такой момент в протоколе вычислений, что до него пруверы были согласны относительно хода вычислений, а после него перестают соглашаться.
        Верификатор не может проверить все $2^n$ строк протокола, однако он может найти строку, в которой версии пруверов начинают расходиться, с помощью бинарного поиска. Для завершения общего описания алгоритма остается сказать, что схема платежей служит тому, что в случае, если для данного входа $x$ существуют ветви вычислений, приводящие к его принятию, пруверы будут обязательное придерживаются одной из них. Таким образом, если $x \notin L$, то пруверы следуют произвольной ветви вычислений и верификатор убеждается, что прав $P_2$, а если $x \in L$, то пруверы следуют одной из ветвей, приводящей к принятию $x$, и верификатор убеждается в правоте $P_1$.

        Перейдем теперь к более детальному описанию алгоритма. Возьмем натуральное $q$ достаточно большое, чтобы закодировать состояние считывающей головки, основной и протокольной ленты. Подробнее, достаточно взять $q = |A| \times (3|A||S| + 1) \times (|S| + 1)$, то есть закодировать состояние каждой ячейки основной ленты и каждой ячейки протокольной ленты, а состояние головки добавить в код той ячейки, над которой она находится. Таким образом, полное состояние машины Тьюринга можно задать функцией $g: \{0, 1\}^n \longrightarrow \{0\ldots q\}$. Выберем систему кодирования так, чтобы состояние пустой ячейки кодировалось числом 0.

        Возьмем простое число $p > n^2$ и рассмотрим $f$ --- мультилинейное продолжение $g$ на $\mathbb{Z}_p$, то есть функцию $f: \{1\ldots p\}^n \longrightarrow \{1 \ldots p\}$ такую, что она линейна по каждому аргументу (по модулю $p$) и на $\{0, 1\}^n$ совпадает с $g$.

        В начале алгоритма верификатор спрашивает у $P_1$, принимает ли $M$ вход $x$. Если прувер $P_1$ отвечает отрицательно, то алгоритм завершается и назначаются платежи $(0, 0)$.
        В противном случае верификатор проводит бинарный поиск по строкам протокола следующим образом. На каждом шаге он поддерживает максимальный номер $G$ <<хорошей>> строки (то есть той, про состояние машины в которой пруверы $P_1$ и $P_2$ согласны) и минимальный номер $B$ <<плохой>> строки (о состоянии в которой пруверы не согласны). Изначально $G=1$ и $B=2^n$. Дополнительно прувер выбирает случайные $a$ и $b \in \{0, \ldots, p\}^n$, задающие прямую $L=ax + b$. Он отсылает $a$ и $b$ пруверу $P_1$, а также выбирает случайную точку $c_1 = a t_1 + b$ на $L$ и отсылает $P_2$.

        На каждом шаге бинарного поиска прувер выбирает номер строки $k = \left[\frac{G + B}{2}\right]$, которую он собирается проверить, и отсылает его пруверам. Прувер $P_1$ отсылает верификатору коэффициенты многочлена $P_k$, который является сужением функции $f^1_k$ --- состояния машины в строке $k$ по версии $P_1$ --- на прямую $L$ (то есть $P_k(x) = f^1_k(ax + b)$). Прувер $P_2$ отсылает верификатору $y_k = f^2_k(c_1)$.

        Верификатор проверяет правда ли, что $y_k = P_k(t_1)$. Если равенство выполняется, то с большой вероятностью $f^1_k \equiv f^2_k$ и верификатор устанавливает $G = k$, иначе он устанавливает $B = k$. Затем производится следующий шаг бинарного поиска.

        Бинарный поиск заканчивается в тот момент, когда $B = G + 1$, то есть найдены две соседних строки таких, что про состояние в первой из них пруверы согласны, а про состояние в следующей не согласны. Верификатор проводит проверку того, кто из пруверов лжет, следующим образом.

        Заметим, что при переходе от строки $G$ к строке $B$ значение функции $f$ поменялось не более, чем в двух точках: могло поменяться состояние той ячейке, где находилась считывающая головка, и той ячейки, куда она передвинулась. Верификатор запрашивает у $P_1$ и $P_2$ информацию о том, какие ячейки по их версии поменялись при переходе. А затем запрашивает у них версии о состояниях всех ячеек, которые могли поменяться (всего не более четырех ячеек), в строке $G$. Также верификатор запрашивает у пруверов информацию о том, какое правило перехода использовалось при переходе из строки $G$ в строку $B$. Если версии пруверов о выбранном правиле перехода не совпадают, то алгоритм завершается и пруверы получают штраф $(-1, -1)$.

        Если пруверы сообщили одинаковые версии о состоянии активных ячеек, то верификатор может посчитать разность $f_B - f_G$ (она зависит только от состояний изменившихся ячеек) и сверить ее с $P_B - P_G$ и $y_B - y_G$. Таким образом выясняется, кто из пруверов лжет. Если соврал $P_1$, то назначаются награды $(-1, 1)$, иначе --- $(1, 0)$.

        Иначе существует ячейка $c$, про состояние которой пруверы не согласны. Обозначим $s_1$ и $s_2$ --- состояние этой ячейки по версии $P_1$ и $P_2$ соответственно. Верификатору нужно сверить состояние этой ячейки с теми данными, которые пруверы сообщали ранее ($P_G$ и $y_G$). Для этого он выбирает случайную точку $c_2$ на прямой $L$ и передает пруверу $P_2$ коэффициенты прямой $L_2 = a'x + b'$, проходящей через точки $c$ и $c_2$. Прувер $P_2$ отвечает коэффициентами многочлена $P'(x) = f^2_G(a'x + b')$. Верификатор проверяет, что значение $P'$ в точке, соответствующей точке $c$, совпадает с $s_2$, то есть показания $P_2$ согласуются друг с другом, а затем, что совпадают значения $P_G$ и $P'$ в точках, соответсвующих $c_2$. Если они не совпадают, то второй прувер лжет и назначаются платежи $(1, 0)$, иначе получается, что $P_2$ ответил верно и лжет $P_1$, поэтому назначются платежи $(-1, 1)$.

        Приведем обоснование корректности данного алгоритма (подробное доказательство приведено в следующем разделе). Прувер $P_1$ может либо спасовать и получить $0$, либо получить $+1$ или $-1$ в зависимости от того, принимает ли рассматриваемая ветвь вход. Таким образом, если $x \notin L$, то он будет пасовать, а если $x \in L$, то он не спасует и будет придерживаться ветви, которая принимает вход, что заставит второго прувера так же придерживаться этой ветви. Угроза второго прувера сменить ветвь на отвергающую вход неправдоподобна: при таком ходе игры первый прувер в любом случае получит $-1$, то есть менять стратегию не будет, то есть второй прувер добьется снижения своей награды с $0$ до $-1$. Значит, ответ прувера $P_1$ в начале алгоритма дает ответ на поставленный вопрос.

        \section{Доказательство корректности}
        \begin{theorem}Определенная выше система рациональных интерактивных доказательств с коммуницирующими пруверами удовлетворяет условиям из определения $\textbf{comm-ncRIP}$ для языка, задаваемого машиной Тьюринга из определения алгоритма.\end{theorem}
        \begin{proof}Требуется показать, что в описанной игре существует УСР и при любом УСР верификатор получает правильный ответ.

            Рассмотрим следующий стратегический профиль. Если $x \notin L$, то $P_1$ пасует в начале алгоритма, иначе он строит протокол выполнения данной машины Тьюринга на лексикографически первой ветви среди тех, которые принимают вход $x$ и далее отвечает согласно протоколу. Игрок $P_2$ так же придерживается данной ветви за тем исключением, что в итоговой строчке протокола записано, что машина отвергает вход (таким образом, эта строчка не получается из прошлой корректным переходом машины Тьюринга по выбранному в данной ветви правилу). Тогда на каждом шаге бинарного поиска проверка $y_k = P_k(t_1)$ выполняется и в итоге получается $B = 2^k$, $G = 2^k - 1$. Проверка активного региона показывает, что $P_2$ дает неправильную информацию о состоянии ленты в строке $2^k$ и алгоритм завершается.

            Покажем, что указанный профиль является УСР. 
        \end{proof}
        \section{Расширение на большие классы языков}
        \section{Верхние оценки}
\newpage
\printbibliography


\end{document}
