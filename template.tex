\documentclass[14pt, a4paper]{extreport}

\linespread{1.5}

\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{titlesec}
\usepackage[centertags]{amsmath}
\usepackage{amsthm,amsfonts,amssymb}
\usepackage{indentfirst}
\usepackage{csquotes}

\usepackage{extsizes}
\usepackage[left=25mm,right=10mm,top=20mm,bottom=20mm,bindingoffset=0cm]{geometry}

\usepackage{cmap}
\usepackage{multirow}
\usepackage{float}
\usepackage{mathtools}
\DeclarePairedDelimiter\ceil{\lceil}{\rceil}
\DeclarePairedDelimiter\floor{\lfloor}{\rfloor}


%\usepackage{pscyr}
\RequirePackage{graphicx}
\RequirePackage{subfig}
\usepackage{thmtools}   
\usepackage{hyperref}
\usepackage[nameinlink]{cleveref}


\newtheorem{lemma}{\indent Лемма}
\newtheorem{theorem}{\indent Теорема}
\newtheorem{corollary}{\indent Следствие}
\newtheorem{problem}{\indent Задача}
\newtheorem{remark}{\indent Замечание}
\newtheorem{definition}{\indent Определение}
\newtheorem{proposition}{\indent Утверждение}
\newtheorem{example}{\indent Пример}
\newtheorem{notation}{\indent Обозначение}

\crefname{lemma}{л.}{л.}
\crefname{theorem}{теор.}{теор.}
\crefname{corollary}{след.}{след.}
\crefname{definition}{опр.}{опр.}
\crefname{proposition}{утв.}{утв.}
\crefname{example}{прим.}{прим.}
\crefname{notation}{обозн.}{обозн.}
\crefname{remark}{замеч.}{замеч.}

\crefname{theorem}{Теорема}{Теорема}
\newcommand{\order}[2]{#1_{(#2)}}

\newcommand{\T}{^{\text{\tiny\sffamily\upshape\mdseries T}}}

\graphicspath{{./img/}}


\def\XYtext(#1,#2)#3{\rlap{\kern#1\lower-#2\hbox{#3}}}
\newcommand{\word}{\{0, 1\}^*}
\newcommand{\defeq}{\overset{\underset{\mathrm{def}}{}}{=}}
\newcommand{\poly}{\textit{poly}}
\newcommand{\pr}[2]{\textbf{Pr}_{#1}\left(#2\right)}
\newcommand{\set}[1]{\left\{#1\right\}}

% Переопределение вставки графики
\newcounter{PictureNo}

\hyphenpenalty 100
\tolerance 10000


\newenvironment{Proof}%
    {\par\noindent{\bf Доказательство.}}%
    {\hfill$\scriptstyle\blacksquare$}

\usepackage[
    backend=biber,
    sorting=nyt,
]{biblatex}
\addbibresource{thesis.bib}

\addto\captionsenglish{\renewcommand{\figurename}{Рисунок}}
\addto\captionsenglish{\renewcommand{\tablename}{Таблица}}
\addto\captionsenglish{\renewcommand{\bibname}{Список использованных источников}}
\captionsetup[figure]{labelfont=footnotesize,textfont=footnotesize}
\captionsetup[table]{labelfont=footnotesize,textfont=footnotesize}

\addto\captionsenglish{\renewcommand{\proofname}{Доказательство}}

\makeatletter % эта строка НЕОБХОДИМА!
\renewcommand{\@chapapp}{Глава} 
\addto\captionsenglish{% Replace "english" with the language you use
  \renewcommand{\contentsname}%
    {Оглавление}%
}

\titleformat{\chapter}[display]
{\normalfont\bfseries\center}
{Глава \thechapter. }{0em}{}

\titleformat{\section}[block]
{\normalfont\bfseries\center}
{\thesection. }{0em}{}

\begin{document}
\begin{center}
\hfill \break
\footnotesize{Федеральное государственное автономное образовательное учреждение 
высшего образования}\\ 
\small{\textbf{<<Московский физико-технический институт (государственный университет)>>}}\\
\hfill \break
\normalsize{Факультет инноваций и высоких технологий}\\
\normalsize{Кафедра дискретной математики}\\
\end{center}
\footnotesize{\textbf{Направление подготовки:} 03.03.01 Прикладные математика и физика}\\
\hfill \break
\hfill \break
\hfill \break
\hfill \break
\begin{center}
\large{\textbf{Рациональные интерактивные доказательства}}\\
\normalsize{Бакалаврская работа}\\
\hfill \break
\hfill \break
\end{center}
 
\hfill \break
 
\begin{flushright}
\footnotesize{ 
\begin{tabular}{rl}
\textbf{Обучающийся:} & Зинов Николай Александрович \\
 & \underline{\hspace{3cm}} \\\\
\textbf{Научный руководитель:} & к. ф.-м. н., \\
            & Д. В. Мусатов \\
 & \underline{\hspace{3cm}} \\\\
\end{tabular}
}
\end{flushright}

\hfill \break
\hfill \break
\hfill \break
\hfill \break
\hfill \break
\hfill \break
\begin{center} Москва 2018 \end{center}
\thispagestyle{empty} % выключаем отображение номера для этой страницы
 
% КОНЕЦ ТИТУЛЬНОГО ЛИСТА
 
\newpage
\normalsize

\chapter*{Аннотация}
В данной работе исследуется отрасль теории интерактивных доказательств, рациональные интерактивные доказательства с несколькими пруверами, и ставится задача определения вычислительной силы данной системы доказательств при снятии ограничения на взаимодействие между пруверами. Показывается, что класс $\textbf{comm-ncRIP}$ языков, вычислимых такой системой, совпадает с исходным классом $\textbf{ncRIP}$. Помимо теоретической ценности предложенный протокол представляет интерес в приложении к системам облачных вычислений и криптовалют.
\tableofcontents{}
\chapter*{Введение}
Концепция интерактивных доказательств в теории сложности вычислений была предложена достаточно давно Babai и Moran~\cite{babai1988arthur} и Goldwasser, Micali и Rackoff~\cite{goldwasser1989ip}. Данная концепция состоит в том, чтобы рассматривать взаимодействие двух сторон: Верификатора (или Артура) и Прувера (Мерлина, далее в этой работе будет использоваться терминология верификатор-прувер). Верификатор вычислительно ограничен и может использовать только те функции, которые вычислимы на вероятностной машине Тьюринга за полиномиальное время. Однако, он может обмениваться информацией с вычислительно неограниченным Прувером. Ставится задача определения класса (обозначаемого $\textbf{IP}$) задач, для которых существуют протоколы, позволяющие Верификатору, с помощью взаимодействия с Прувером, получить ответ и убедиться в его правильности даже в том случае, если Прувер не является честным, то есть может пытаться отклониться от протокола с целью ввести Верификатора в заблуждение.

Для понимания данной работы также необходимо особо отметить концепцию доказательств с несколькими пруверами. В ней Верификатор может общаться не с одним, а со многими вычислительно неограниченными пруверами, которые не могут общаться между собой, что дает Верификатору возможность сверять между собой ответы пруверов и таким образом решать задачи более сложные, чем позволяют стандартные интерактивные доказательства. Полная характеризация этого класса задач дана Babai, Fortnow и Lund~\cite{babai1991mip}.

В последнее время интерес к теме интерактивных доказательств усилился в связи с появлением различных платформ для облачных вычислений, которые по сути являются системой делегации вычислений. Сторона с ограниченными вычислительными возможностями (клиент облачного провайдера) использует вычислительные мощности второй стороны (сервера в вычислительном облаке) для решения своих задач. Однако, на данный момент пользователи облачных сервисов полагаются на то, что провайдер производит вычисления верно, а не, например, генерирует ответы случайным образом. При текущем положении вещей, когда услуги по предоставлению вычислительных мощностей оказывают крупные компании, такие как Amazon и Google, косвенным подтверждением честности проводимых вычислений может служить репутация компании. Использование свободных вычислительных мощностей персональных компьютеров успешно производится, например, в рамках проекта BOINC~\cite{anderson2004boinc} для таких задач, как поиск больших простых чисел, однако каждое найденное число независимо проверяется для исключения обмана. Внедрение практических методов проверяемой делегации вычислений (verifiable delegation of computations), то есть протоколов, позволяющих заказчику вычисления эффективно проверять корректность его результата, позволит использовать подобные BOINC схемы для прикладных вычислений.

Другой областью приложения интерактивных доказательств в ближайшем будущем могут стать криптовалюты. Безопасность наиболее популярной системы --- Bitcoin, а также большинства других основана на концепции proof of work~\cite{nakamoto2008bitcoin}. Суть метода состоит в том, что пользователи системы должны проводить затратные вычисления и приводить подтверждения факта их проведения. Интерактивные доказательства могут дать способ заменить в этом качестве бесполезные вычисления на решение прикладных задач.

В свете описанных приложений, Azar и Micali~\cite{azar2012rational} предложили концепцию рациональных доказательств, где Верификатор по итогам общения с Прувером выплачивает ему награду, размер которой известным образом зависит от ответов Прувера. Требование того, чтобы Прувер не мог обмануть Верификатора заменяется требованием рациональности: для максимизации ожидаемой награды Пруверу наиболее выгодно отвечать честно.

В ходе развития идеи рациональных доказательств Chen, McCauley и Singh получили характеризации классов рациональных доказательств с несколькими пруверами --- как в модели, где пруверы максимизируют общую награду~\cite{chen2016mrip}, так и в модели, где каждый прувер максимизирует свою индивидуальную награду~\cite{chen2017noncoop}.

В выбранной ими постановке задачи предполагается, как и в~\cite{babai1991mip}, что пруверы не могут общаться между собой. В классических интерактивных доказательствах это требование является существенным. Действительно, если разрешить пруверам общаться между собой, то, в силу их неограниченности, общение с ними можно свести к общению с одним прувером. Однако в модели рациональных доказательств такое сведение не возможно: даже при том условии, что пруверам разрешено общаться, они могут воздерживаться от общения, если они поставлены в условия конкуренции, то есть когда пруверу не выгодно передавать какую-то информацию другому пруверу.

Целью данной работы является определение вычислительных возможностей рациональных доказательств с несколькими коммуницирующими пруверами.

Основным результатом является то, что класс языков, позволяющий рациональное доказательство с коммуницирующими пруверами совпадает с клаccом языков, разрешимых исходной системой. Также стоит отметить, что приведенный в данной работе протокол рационального доказательства является технически более простым, чем предложенный в~\cite{chen2017noncoop}, так как в отличие от последнего не использует классический протокол для класса $\textbf{MIP}$, в котором используются сложные техники, такие как multilinearity testing, а опирается на элементарный алгоритм ранее предложенный Feige, Uriel и Kilian~\cite{feige1997refereed} в задаче игр с рефери (refereed games).
\chapter{Основные понятия классической теории сложности вычислений}
В данном разделе вводятся те определения и сложностные классы, которые необходимы для дальнейшего изложения.
\begin{notation}$\word$ обозначает множество всех двоичных слов, то есть конечных строки из символов $0$ и $1$. Языком называется подмножество данного множества.
\end{notation}
\section{Машины Тьюринга}
В первую очередь необходимо ввести понятие машины Тьюринга, так как с его помощью определяются базовые сложностные классы, а также оно используется ниже непосредственно. Введем определение в достаточно общем виде.
\begin{definition}Недетерминированная машина Тьюринга (НМТ) с $N$ лентами на конечном алфавите $A$ ($\set{\emptyset, 0, 1} \subseteq A$) и конечном множестве состояний $S$ ($\set{I, N, Y} \subseteq S$) задается функцией правил перехода $f: A \times S \longrightarrow A \times 2^S \times \{-1, 0, 1\}$ и функцией выбора ленты $h: S \longrightarrow \set{1\ldots N}$.

Состоянием ДМТ называется набор $\left(p_1, \ldots, p_N, s, T_1, \ldots, T_N\right)$, где $p_i \in \mathbb{N}$ --- положения головок, $s \in S$ --- внутреннее состояние и $T_i: \mathbb{N} \longrightarrow A$ такие, что $T_i(n) \neq \emptyset$ лишь в конечном числе точек, --- состояния лент.

Графом вычисления ДМТ на входе $x \in \word$ называется ориентированный граф, вершины которого являются состояниями НМТ, такой, что
\begin{enumerate}
    \item В графе существует вершина-начальное состояние $v_I = \left(0, \ldots, 0, I, X, \emptyset, \ldots, \emptyset\right)$, где $X(n)$ равно $n$-му биту $x$, либо $\emptyset$, если он отсутствует.
    \item Если в графе есть вершина $v = \left(p_1, \ldots, p_N, s, T_1, \ldots, T_N\right)$, $h(s) = i$ и $f(T_i(p_i), s) = (a, S', d)$, то для каждого $s' \in S'$ в графе также присутствует вершина $w = \left(p_1, \ldots, p_{i-1}, p_i + d, p_{i+1}, \ldost, p_N, s', T_1, \ldots, T_{i-1}, T'_i, T_{i+1}, \ldots, T_N\right)$ ($T_i'(p) = a$, а в остальных точках она совпадает с $T_i$), а также проведена дуга из $v$ в $w$.
\end{enumerate}

Ветвью вычислений называется ориентированный путь в графе вычислений, начинающийся в начальном состоянии. Протоколом вычислений на данной ветви называется последоватьность состояний вдоль этого пути.
Если в какой-то из строк протокола определенной ветви выполнено $s \in \set{N, Y}$, то говорится, что данная ветвь останавливается на входе $x$ и принимает его, если $s = Y$, и отвергает, если $s = N$. 

Недетерминированная машина Тьюринга останавливается за время $t$, если каждая ее ветвь останавливается и доходит до терминального состояния не более чем за $t$ шагов. 
Недетерминированная машина Тьюринга принимает вход $x$, если существует ветвь вычислений, которая принимает этот вход.
\end{definition}
Теперь сузим данное определение следующим образом.
\begin{definition}
    Детерминированной машиной Тьюринга (ДМТ) называется машина Тьюринга, у которой в любом состоянии возможен единственный переход. Граф вычислений такой машины Тьюринга содержит только одну ветвь, так что можно говорить о протоколе вычислений ДМТ и результате работы ДМТ не упоминая ветви вычислений.
\end{definition}
Также в определении сложностных классов потребуется понятие оракула
\begin{definition}
    Недетерминированная машиной Тьюринга с оракулом $L \subseteq \word$ отличается от обычной тем, что множество состояний $S$ содержит дополнительно элементы $Q$, $G$ и $B$, а граф вычислений строится следующим образом (добавляется условие)
    \begin{enumerate}
        \item В графе существует вершина-начальное состояние $v_I = \left(0, \ldots, 0, I, X, \emptyset, \ldots, \emptyset\right)$, где $X(n)$ равно $n$-му биту $x$, либо $\emptyset$, если он отсутствует.
        \item Если в графе есть вершина $v = \left(p_1, \ldots, p_N, s, T_1, \ldots, T_N\right)$, $s \neq Q$, $h(s) = i$ и $f(T_i(p_i), s) = (a, S', d)$, то для каждого $s' \in S'$ в графе также присутствует вершина $w = \left(p_1, \ldots, p_{i-1}, p_i + d, p_{i+1}, \ldost, p_N, s', T_1, \ldots, T_{i-1}, T'_i, T_{i+1}, \ldots, T_N\right)$ ($T_i'(p) = a$, а в остальных точках она совпадает с $T_i$), а также проведена дуга из $v$ в $w$.
        \item Если в графе есть вершина $v = \left(p_1, \ldots, p_N, Q, T_1, \ldots, T_N\right)$, то в графе есть вершина $w = \left(p_1, \ldots, p_N, s, T_1, \ldots, T_N\right)$ ($s = G$, если $T_N$ корректно задает слово $x'$ и выполнено $x' \in L$, а иначе $s = B$), а также проведена дуга из $v$ в $w$.

    \end{enumerate}

\end{definition}
\section{Базовые сложностные классы}
Сразу следует отметить, что здесь вводятся лишь те классы, которые необходимы в последующем, так что этот раздел не претендует на полноту.
\begin{definition}[Класс \textbf{P}]Язык $L \in \textbf{P}$ тогда и только тогда, когда существует такая детерминированная машина Тьюринга и такой полином $F$, что на любом слове $x \in \word$ машина Тьюринга останавливается не более чем за $F(|x|)$ шагов и принимает вход тогда и только тогда, когда $x \in L$.
\end{definition}
\begin{definition}[Класс \textbf{EXP}]Язык $L \in \textbf{EXP}$ тогда и только тогда, когда существует такая детерминированная машина Тьюринга и такой полином $F$, что на любом слове $x \in \word$ машина Тьюринга останавливается не более чем за $\exp\left(F(|x|)\right)$ шагов и принимает вход тогда и только тогда, когда $x \in L$.
\end{definition}
\begin{definition}[Класс \textbf{NEXP}]Язык $L \in \textbf{NEXP}$ тогда и только тогда, когда существует такая недетерминированная машина Тьюринга и такой полином $F$, что на любом слове $x \in \word$ машина Тьюринга останавливается не более чем за $\exp\left(F(|x|)\right)$ шагов и принимает вход тогда и только тогда, когда $x \in L$.
\end{definition}
\begin{definition}[Класс \textbf{PSPACE}]Язык $L \in \textbf{PSPACE}$ тогда и только тогда, когда существует такая детерминированная машина Тьюринга и такой полином $F$, что на любом слове $x \in \word$ машина Тьюринга останавливается, причем на протяжении протокола суммарное число непустых элементов лент не превышает $F(|x|)$, а также машина принимает вход тогда и только тогда, когда $x \in L$.
\end{definition}
\begin{definition}[Класс оракульных вычислений]Обозначим $A$ и $B$ --- классы языков, $\alpha(n)$ --- некоторая функция. Язык $L \in A^{B\left[O(\alpha(n))\right]}$, если существует такая машина Тьюринга с оракулом $L' \in B$, которая удовлетворяет условиям, накладываемым в определении класса $A$, на входе $x$ делает не более $\alpha(|x|)$ запросов к оракулу и останавливается, а также принимает вход тогда и только тогда, когда $x \in L$.
\end{definition}
\chapter{Интерактивные доказательства}
\section{Основные определения}
Существуют разнообразные модели интерактивных доказательств. Ниже приведено, насколько это возможно, наиболее общее определение системы интерактивного доказательства. Конкретные модели получаются из него введением дополнительных условий на входные данные и вычислительные возможности верификатора и прувера.
\begin{definition}\label{ip_system}
    Системой интерактивных доказательств называется совокупность двух функций: $P: \word \longrightarrow \word$ --- прувера и $V: \word \longrightarrow \word \cup \{Y, N\}$ --- верификатора (запись $\word$ означает множество конечных слов из символов $0$ и $1$). Протоколом работы системы интерактивных доказательств на входе $x \in \word$, случайных битах верификатора $v \in \word$, случайных битах прувера $p \in \word$, общих случайных битах $\left\{c_i\right\}_{i=1}^{\infty}$ является последовательность слов, определяемая следующим образом (предполагается, что кортежи слов однозначно кодируются в слова):
    \begin{enumerate}
        \item $q_1 \defeq V(x, v, c_1)$
        \item $r_1 \defeq P(x, p, c_1, q_1)$
        \item $q_2 \defeq V(x, v, c_1, c_2, q_1, r_1)$
        \item $r_2 \defeq P(x, p, c_1, c_2, q_1, r_1, q_2)$\\
            \vdots
        \item [(2k-1).] $q_k \defeq V(x, v, c_1, \ldots, c_k, q_1, r_1, \ldots, q_{k-1}, r_{k-1})$
        \item [(2k).] $r_k \defeq P(x, p, c_1, \ldots, c_k, q_1, r_1, \ldots, r_{k-1}, q_k)$
    \end{enumerate}
    Построение протокола завершается при условии, что очередное $q_k \in \{Y, N\}$. Если $q_k = Y$, то говорится, что данная система интерактивных доказательств принимает вход $x$, иначе, если $q_k = N$, то говорится, что система отвергает вход $x$.

    Результатом работы системы доказательств называется $q_k$ --- сообщение верификатора на последней строчке протокола. Результат работы системы $\langle V, P\rangle$ обозначается $V^{P}_{v, p, c_i}(x)$.
\end{definition}
При фиксированной модели интерактивных доказательств можно рассмотреть класс языков (подмножеств множества $\word$), разрешаемых этой системой с достаточно большой вероятностью. Здесь приводится определение классического класса $\textbf{IP}$, предложенного в~\cite{goldwasser1989ip}.
\begin{definition}\label{ip}
    Классом $\textbf{IP}$ называется множество языков такое, что $L \in \textbf{IP}$ тогда и только тогда, когда существует система интерактивного доказательства $\langle V, P\rangle$ со случайными битами верификатора (без случайных битов прувера и общих случайных битов), удовлетворяющая следующим свойствам:
    \begin{enumerate}
        \item Верификатор полиномиально ограничен, то есть на каждом шаге протокола функция $V$ вычислима на детерминированной машине Тьюринга за время, не превосходящее $\poly(|x|)$.
        \item Для любого слова $x \in L$ и любых случайных битов интерактивное доказательство завершается за конечное число строчек протокола, ограниченное $\poly(|x|)$.
        \item Для любого слова $x \in L$ выполнено $\pr{v}{V^P_{v}(x) = Y} \geqslant \frac{2}{3}.$
        \item Для любого слова $x \notin L$ и для любой функции $P'$ выполнено\\$\pr{v}{V^{P'}_{v}(x) = Y} \leqslant \frac{1}{3}.$
    \end{enumerate}
\end{definition}
Также следует упомянуть другую классическую систему интерактивных доказательств --- игры Артура-Мерлина, в которых имеются только общие случайные биты ($c_{i}$). Данная система предложена в~\cite{babai1988arthur} и в данной работе далее рассматриваться не будет.
\section{Интерактивные доказательства с несколькими пруверами}
Обобщение определения на случай нескольких пруверов производится естественным образом: имеется не одна, а несколько функций-пруверов и на каждом шаге верификатор выбирает, кто из них будет ему отвечать. Формально это можно записать следующим образом.
\begin{definition}\label{mip_system}
    Системой интерактивных доказательств с $n$ пруверами называется совокупность функций: $P_i: \word \longrightarrow \word, i \in \set{1\ldots n}$ --- пруверов и $V: \word \longrightarrow \left(\word \cup \{Y, N\}\right) \times \set{1 \dots n}$ --- верификатора. Протоколом работы системы интерактивных доказательств на входе $x \in \word$, случайных битах верификатора $v \in \word$, случайных битах пруверов $\left\{p_i\in \word\right\}_{i=1}^{\infty}$ и общих случайных битах $\left\{c_i\in \word\right\}_{i=1}^{\infty}$ является последовательность слов, определяемая следующим образом:
    \begin{enumerate}
        \item $(q^{s_1}_1, s_1) \defeq V(x, v, c_1)$
        \item $r^{s_1}_1 \defeq P_{s_1}(s_1, x, p_{s_1}, c_1, q^{s_1}_1)$
        \item $(q^{s_2}_1, s_2) \defeq V(x, v, c_1, c_2, q^{s_1}_1, r^{s_1}_1)$
        \item $r^{s_2}_2 \defeq P_{s_2}(s_2, x, p_{s_2}, c_1, c_2, q^{s_2}_1)$\\
            \vdots
        \item[(2k-1).] $(q^{s_k}_l, s_k) \defeq V(x, v, c_1, \ldots, c_k, q^1_1, r^1_1, \ldots, q^1_{l_1-1}, r_{l_1-1}, \ldots, q^n_1, r^n_1, \ldots, q^n_{l_n-1}, r_{l_n-1})$
        \item[(2k).] $r^{s_k}_l \defeq P(s_k, x, p_{s_k}, c_1, \ldots, c_k, q^{s_k}_1, r^{s_k}_1, \ldots, r^{s_k}_{l-1}, q^{s_k}_l)$
    \end{enumerate}
    Аналогично случаю единственного прувера, построение протокола завершается при условии, что очередное $q_k \in \{Y, N\}$. Если $q_k = Y$, то говорится, что данная система интерактивных доказательств принимает вход $x$, иначе, если $q_k = N$, то говорится, что система отвергает вход $x$.

    Результатом работы системы доказательств называется $q_k$ --- сообщение верификатора на последней строчке протокола. Результат работы системы $\langle V, P_1, \ldots, P_n\rangle$ обозначается $V^{P_1, \ldots, P_n}_{v, p_i, c_i}(x)$.
\end{definition}

Отдельно необходимо отметить, что в определенной выше системе пруверы не могут общаться между собой (в формальном определении это выражается в том, что функции $P_1, \dots, P_n$ не принимают дополнительных входов, кроме случайных бит и протокола своего прошлого общения с верификатором). Если разрешить пруверам общаться, то они могут передавать друг другу недостающие входные данные. Если дополнительно выбрать функции-пруверы одинаковыми (объединить функции в одну, сделав разбор случая по аргументу $s$), то полученная система доказательств не будет отличаться от системы с одним прувером: вне зависимости от того, какого прувера выберет верификатор, его ответ вычисляется как фиксированная функция от всего протокола общения, где недостающие сообщения получены им от других пруверов. Таким образом, полученная при снятии запрета на общение пруверов система доказательств обладает той же силой, что и система с одним прувером.

Аналогично классу $\textbf{IP}$ определяется класс $\textbf{MIP}$.

\begin{definition}\label{mip}
    Классом $\textbf{MIP}$ называется множество языков такое, что $L \in \textbf{MIP}$ тогда и только тогда, когда существует система интерактивного доказательства с несколькими пруверами $\langle V, P_1, \ldots, P_n\rangle$ со случайными битами верификатора (без случайных битов пруверов и общих случайных битов), удовлетворяющая следующим свойствам:
    \begin{enumerate}
        \item Верификатор полиномиально ограничен, то есть на каждом шаге протокола функция $V$ вычислима на детерминированной машине Тьюринга за время, не превосходящее $\poly(|x|)$.
        \item Для любого слова $x \in L$ и любых случайных битов интерактивное доказательство завершается за конечное число строчек протокола.
        \item Для любого слова $x \in L$ выполнено $\pr{v}{V^{P_1, \ldots, P_n}_{v}(x) = Y} \geqslant\frac{2}{3}$
        \item Для любого слова $x \notin L$ и для любых функций $P'_1, \ldots, P'_n$ выполнено\\$\pr{v}{V^{P'_1, \ldots, P'_n}_{v}(x) = Y} \leqslant \frac{1}{3}$
    \end{enumerate}
\end{definition}
\section{Характеризации классов $\textbf{IP}$ и $\textbf{MIP}$}
Под характеризацией сложностного класса языков понимается нахождение иным образом определенного класса, равного ему. Обычно характеризация проводится с помощью классов языков, вычислимых на детерминированных и недетерминированных машинах Тьюринга с определенными ограничениями времени или памяти. Для классов интерактивных доказательств справедливы следующие характеризации.
\begin{theorem}$\textbf{IP} = \textbf{PSPACE}$.~\cite{shamir1992ip}
\end{theorem}
\begin{theorem}$\textbf{MIP} = \textbf{NEXP}$.~\cite{babai1991mip}\end{theorem}

\chapter{Рациональные доказательства}
\section{Основная концепция}
В определенной выше модели интерактивных доказательств требуется, чтобы с большой вероятностью прувер получил правильный ответ, даже если прувер пытается его обмануть. Данное требование влечет за собой необходимость верификатору проверять ответы прувера на корректность. В концепции рациональных доказательств предлагается считать пруверов рациональными, то есть всегда действующими для максимизации своей ожидаемой награды. Награда назначается верификатором по результатам общения с прувером по наперед известному всем пруверам правилу. 

Система рациональных доказательств с несколькими пруверами представляет собой обычную систему интерактивных доказательств в сопокупности с набором функций наград $R_i: \word \longrightarrow \mathbb{N}$, сопоставляющих протоколу вычисления целочисленную награду пруверу $P_i$. Заметим, что наличие наград не влияет на алгоритм постоения протокола вычисления.

В случае одного прувера формализация того, что он максимизирует свою награду производится простым образом и получается следующее определение.
\begin{definition}\label{rip}
    Классом $\textbf{RIP}$ называется множество языков такое, что $L \in \textbf{RIP}$ тогда и только тогда, когда существует система рационального интерактивного доказательства $\langle V, P, R\rangle$ со случайными битами верификатора (без случайных битов прувера и общих случайных битов), удовлетворяющая следующим свойствам:
    \begin{enumerate}
        \item Верификатор полиномиально ограничен, то есть на каждом шаге протокола функция $V$, а также $R(Q(V, P, x, v))$, где $Q$ --- протокол работы, вычислимы на детерминированной машине Тьюринга за время, не превосходящее $\poly(|x|)$.
        \item Пусть прувер действует оптимально, то есть на любом шаге алгоритма ему не выгодно отклоняться от протокола, или, формально, на любом шаге $i$ протокола $P = \textbf{argmax}_{P'} \mathbb{E}_v R(Q'(V, P, P', i))$ (где $Q'(V, P, P', i)$ означает протокол, где до i-го шага действует прувер $P$, а затем $P'$). Тогда система доказательств выдает правильный ответ, то есть $\forall x: x \in L \iff V^{P}_{v}(x) = Y$.
        \end{enumerate}
    \end{definition}

    \section{Характеризация класса $\textbf{RIP}$}
    Характеризация класса $\textbf{RIP}$ получена Azar и Micali в~\cite{azar2012rational}, где показывается, что этот класс совпадает с классом классических интерактивных доказательств, а именно верна следующая теорема.
    \begin{theorem}
        $\textbf{RIP} = \textbf{IP} = \textbf{PSPACE}$.
    \end{theorem}
    Можно видеть, что в случае одного прувера добавление рациональности не дает преимущества в вычислительной мощности в приведенной модели, что, однако, меняется при переходе к случаю нескольких пруверов.
        \chapter{Случай нескольких пруверов}
        В случае наличия нескольких пруверов определение того, в чем состоит максимизация награды, усложняется. Причиной этого является то, что награда прувера зависит, в общем случае, не только от его действий, но и от действий других пруверов. Для описания поведения пруверов в такой модели используется аппарат теории игр. В ее терминах система рациональных интерактивных доказательств представляет из себя игру с неполной информацией и совершенной памятью в развернутой форме.

        Систему рациональных доказательств можно считать игрой, позицией в которой является полный протокол общения верификатора с пруверами на данный момент, а ходом является сообщение, которое прувер отправляет верификатору. Заметим, что поскольку прувер знает только те сообщения, которые верификатор отправляет ему, то полный протокол ему неизвестен, то есть он не знает текущую позицию.
        Рассмотрим множество всех протоколов, которые получаются из протокола общения верификатора с данным прувером заполнением пропусков всеми корректными с точки зрения алгоритма способами.
        Это \textit{информационное множество} содержит все возможные на текущий момент с точки зрения данного прувера позиции, однако какая именно из них реализуется, ему неизвестно.
        В системе без случайных битов пруверов каждую функцию $P_i$ в обозначениях теории игр можно считать чистой стратегией: она принимает на вход прошлую историю общения верификатора с этим прувером (она задает информационное множество данного прувера) и возвращает ответ верификатору (действие). В случае наличия случайных битов пруверов имеем поведенческую стратегию: случайные биты прувера задают вероятностное распределение по действиям. Стратегическим профилем $s$ будем называть набор стратегий всех игроков.

        \section{Усиленное секвенциальное равновесие}

        Каждый прувер выбирает свою стратегию так, чтобы максимизировать свою награду исходя из стратегий остальных игроков.
        Их взаимная конкуренция приводит к тому, что стратегический профиль приходит к \textit{равновесию}. Определим концепцию решения, которая была предложена для рациональных доказательств Chen et al. в~\cite{chen2017noncoop}.
        Следует отметить, что выбор конкретной концепции решения продиктован условиями доказательства верхней оценки на вычислительную мощность, что будет подробно описано ниже.

        Усиленное секвенциальное равновесие (strong sequential equilibrium) было предложено как уточнение сильного секвенциального равновесия (в англоязычной литературе оно называется просто sequential equilibrium), предложенного Kreps и Wilson~\cite{kreps1982sequential}.

        Назовем верой функцию $\mu$, задающую на каждом информационном множестве $I$ вероятностную меру: для каждой игровой позиции в $I$ она задает вероятность ее реализации по мнению игрока, чей ход в $I$. Естественным образом можно определить ожидаемый выигрыш данного игрока при заданном стратегическом профиле и вере. Наилучшей стратегией при вере $\mu$ будем называть такую стратегию, которая дает максимальный ожидаемый выигрыш при этой вере.
        \begin{definition}[Усиленное секвенциальное равновесие]
            Стратегический профиль $s$ является усиленным секвенциальным равновесием, если для каждого игрока $i$ и каждого информационного множества $I_i$ игрока $i$ выполнено:

            \begin{enumerate}
                \item Если информационное множество $I_i$ достижимо при данном стратегическом профиле (то есть оно реализуется с ненулевой вероятностью), то при условии, что достигнуто информационное множество $I_i$, стратегия игрока $i$ ($s_i$) является наилучшей при фиксированных стратегиях остальных игроков ($s_{-i}$) при вере игрока $i$, полученной из $s$ по правилу Байеса.
                \item Если же информационное множество $I_i$ недостижимо, то при условии того, что достигнуто $I_i$, стратегия $s_i$ является наилучшей против $s_{-i}$ при любой вере игрока $i$.
            \end{enumerate}
        \end{definition}

        Такое определение равновесие накладывает дополнительное условие на оптимальность стратегии в недостижимых информационных множествах. Поэтому, в отличие от секвенциального равновесия, оно существует не для всех игр в развернутой форме с совершенной памятью.

        \section{Рекурсивно-максимальное усиленное секвенциальное равновесие (УСР)}

        Несмотря на строгость условий усиленного секвенциального равновесия в игре может быть несколько равновесий. Чтобы формализовать тот факт, что среди всевозможных равновесий игроки по возможности выбирают то, где награды всех игроков максимальны, требуется дальнейшее уточнение понятия решения.

        Максимальное УСР можно ввести следующим образом: если при стратегиях $s$, являющихся УСР, ожидаемый выигрыш каждого игрока не меньше, чем при любом другом УСР $s'$, то $s$ является максимальным.

        Следуя~\cite{chen2017noncoop} введем следующее определение, предложенное в~\cite{kreps1982sequential}.
        \begin{definition}[Подформа]
            Пусть $I$ --- произвольное информационное множество. Обозначим $H_I$ --- множество всех возможных продолжений протоколов из $I$. $F_I$ --- множество информационных множеств, следующих за $I$, то есть всех информационных множеств, содержащих протоколы из $H_I$.

            $H_I$ является подформой на $I$, если для каждого $I' \in F_I$ все протоколы в нем являются продолжениями протоколов из $I$.

            Высотой подформы называется максимальное число ходов после достижения $I$. При заданной вере на $I$ выигрыш на подформе определяется, как ожидаемый выигрыш при начальной позиции распределенной согласно этой вере.
        \end{definition}

        Теперь можно определить понятие решения следующим образом.

        \begin{definition}[Рекурсивно-максимальное УСР]
            Стратегический профиль $s$ является рекурсивно-максимальным УСР тогда и только тогда, когда $s$ является УСР и выполнены следующие условия:
            \begin{itemize}
                \item Для каждой подформы $H_I$ высоты 1:
                    \begin{itemize}
                        \item Если $I$ достижимо при стратегиях $s$, то $s$ --- максимальное УСР относительно вер, полученных по правилу Байеса.
                        \item Если $I$ не является достижимым, то $s$ должно быть максимальным УСР относительно любых вер.
                    \end{itemize}
                \item Для каждой подформы $H_I$ высоты $>1$:
                    \begin{itemize}
                        \item Если $I$ достижимо при стратегиях $s$, то $s$ --- максимальное среди тех УСР, которые являются рекурсивно-максимальными УСР на всех подформах подформы $H_I$ (относительно вер, полученных по правилу Байеса).
                        \item Если $I$ недостижимо при стратегиях $s$, то $s$ --- максимальное среди тех УСР, которые являются рекурсивно-максимальными УСР на всех подформах подформы $H_I$ (относительно любых вер).
                    \end{itemize}
            \end{itemize}
        \end{definition}

        Теперь можно определить класс рациональных доказательств с несколькими пруверами:

        \begin{definition}
            Язык $L$ лежит в классе рациональных интерактивных доказательств с несколькими пруверами $\textbf{ncRIP}$ тогда и только тогда, когда существует такая система рациональных доказательств с несколькими пруверами, что в ней существует рекурсивно-максимальное УСР и при любом УСР с вероятностью 1 результат работы равен 1, если $x \in L$, и 0 в противном случае.
        \end{definition}

        \section{Зазор полезности}
        Условие максимизации полезности пруверами является очень сильным. Действительно, даже если при некоторой стратегии существует экспоненциально малая вероятность того, что награда прувера уменьшится, требование максимизации означает, что такая стратегия будет запрещена. Естественно будет рассмотреть ослабленную версию этого условия, разрешив пруверам отклоняться оптимальной стратегии при том условии, что их потери в полезности асимптотически не превосходят определенной величины. Данная величина традиционно называется зазором полезности (utility gap). Приведем модифицированное определение класса $ncRIP$ из прошлого раздела, добавив в него зазор полезности.

\begin{definition}
    Язык $L$ лежит в классе рациональных интерактивных доказательств с несколькими пруверами и зазором полезности $O(\alpha(n))-\textbf{ncRIP}$ тогда и только тогда, когда существует такая система рациональных доказательств с несколькими пруверами, что в ней существует рекурсивно-максимальное УСР и при любом УСР результат работы равен $x \in L$ с вероятностью 1, а также выполнено следующее условие.

    Пусть $s^*$ --- рекурсивно-максимальное УСР. Если при некотором стратегическом профиле $s'$ система доказательств дает неверный ответ, то существует подформа $H_I$, достижимая при профиле $s'$, и прувер $P_j$, который отклонился от $s^*$, такие, что
    \[\mathbb{E}\left(R_j|x, (s'_{-I}, s^*_I)\right) - \mathbb{E}\left(R_j|x, s')\right) \geqslant \frac{1}{\alpha(n)}\]
    В формуле выше $(s'_I, s^*_I)$ означает стратегический профиль, полученный применением стратегий из $s^*$ на подформе $H_I$ и стратегий $s'$ вне нее.
\end{definition}
        В завершение данного раздела, приведем характеризации класса $\textbf{ncRIP}$ с разным зазором полезности, полученные Chen et al. в~\cite{chen2017noncoop}.

        \begin{theorem}
            $O(\alpha(n))-\textbf{ncRIP} = \textbf{P}^{\textbf{NEXP}\left[\alpha(n)\right]}$

            В частности:
            \begin{enumerate}
                \item $ O(1)-\textbf{ncRIP} = {\textbf{P}}^{\textbf{NEXP}[O(1)] }$.
                \item $\textit{poly}(n)-\textbf{ncRIP} = \textbf{P}^{\textbf{NEXP}}$.
            \end{enumerate}
        \end{theorem}


        \chapter{Случай коммуницирующих пруверов}

        В данной работе исследуется вариант рациональных доказательств с несколькими пруверами, в котором пруверы могут общаться между собой, то есть обмениваться строками произвольной длины. Сообщения передаются приватно между двумя пруверами, то есть ни остальные пруверы, ни верификатор не могут их прочесть. Можно доказать, что такой вариант имеет, ту же вычислительную силу, что и обычный. Ниже будет приведен алгоритм рационального доказательства с коммуницирующими пруверами и константным зазором полезности для произвольного языка из класса $\textbf{NEXP}$ и доказана его корректность.

        \section{Refereed games}
        Алгоритм для класса $\textbf{NEXP}$, приводимый ниже, является модификацией алгоритма, предложенного Feige и Kilian~\cite{feige1997refereed} в концепции игр с рефери (refereed games). Данная концепция развивалась независимо от рациональных доказательств, хотя фактически является частным случаем рациональных доказательств с несколькими пруверами.

        В игре участвуют два вычислительно неограниченных игрока и полиномиально ограниченный рефери. Рефери обменивается сообщениями с игроками и согласно фиксированному алгоритму (быть может, рандомизированному частными случайными битами рефери) выбирает одного из игроков победителем. Цель каждого из игроков --- выиграть. Для фиксированного класса языков ставится задача построения такого алгоритма рефери, при котором победивший игрок сообщает истинные сведения о принадлежности классу. С точки зрения рациональных доказательств игра с рефери является системой рациональных доказательств с двумя пруверами и нулевой суммой (то есть суммарный выигрыш равен $0$ при любом исходе игры).
        \section{Протокол рационального доказательства для класса $\textbf{NEXP}$}
        В данном разделе строится алгоритм рационального доказательства для произвольного языка из класса $\textbf{NEXP}$.

        Пусть дана недетерминированная машина Тьюринга $M$ с одной лентой, выполняющая проверку принадлежности некоторому языку из класса \textbf{NEXP}. Рассмотрим систему рациональных доказательств с двумя пруверами: $P_1$ и $P_2$, которая позволяет верификатору определить, принимает ли машина $M$ вход $x$. Обозначим $n = |x|$. В силу определения класса \textbf{NEXP}, на любом входе вычисление завершается за время, не превосходящее $2 ^ n$, что означает, что считывающая головка никогда не покидает первых $2^n$ ячеек ленты. Таким образом, протокол вычисления отдельно взятой ветви вычислений данной машины можно записать в виде $2^n$ строк длины $2^n$.

        Итак, задача верификатора состоит в том, чтобы определить, правда ли, что существует ветвь вычислений, которая приводит к принятию $x$. Рассмотрим определенную ветвь вычислений и, в духе игр с рефери, заставим $P_1$ доказывать, что данная ветвь вычислений завершается принятием входного слова, а $P_2$, что отвергает. На высоком уровне абстракции идея алгоритма состоит в том, что каждый из двух пруверов представляет свою версию протокола работы машины Тьюринга, а верификатор определяет, какая версия корректна. Начальное состояние фиксировано и известно верификатору, то есть пруверы должны быть согласны относительно него. Конечное состояние различно --- по версии $P_1$ машина находится в состоянии $Y$, что противоречит версии прувера $P_2$. Значит, найдется такой момент в протоколе вычислений, что до него пруверы были согласны относительно хода вычислений, а после него перестают соглашаться.
        Верификатор не может проверить все $2^n$ строк протокола, однако он может найти строку, в которой версии пруверов начинают расходиться, с помощью бинарного поиска. Для завершения общего описания алгоритма остается сказать, что схема платежей служит тому, что в случае, если для данного входа $x$ существуют ветви вычислений, приводящие к его принятию, пруверы будут обязательное придерживаются одной из них. Таким образом, если $x \notin L$, то пруверы следуют произвольной ветви вычислений и верификатор убеждается, что прав $P_2$, а если $x \in L$, то пруверы следуют одной из ветвей, приводящей к принятию $x$, и верификатор убеждается в правоте $P_1$.

        Перейдем теперь к более детальному описанию алгоритма. Возьмем натуральное $q$ достаточно большое, чтобы закодировать состояние считывающей головки, основной и протокольной лент. Подробнее, достаточно взять $q = |A| \cdot (3|A||S| + 1) \cdot (|S| + 1)$, то есть закодировать состояние каждой ячейки основной ленты и каждой ячейки протокольной ленты, а состояние головки добавить в код той ячейки, над которой она находится. Таким образом, полное состояние машины Тьюринга можно задать функцией $g: \{0, 1\}^n \longrightarrow \{0\ldots q\}$. Выберем систему кодирования так, чтобы состояние пустой ячейки кодировалось числом 0.

        Возьмем простое число $p > \textbf{max}\set{q, n^2}$ и рассмотрим $f$ --- мультилинейное продолжение $g$ на $\mathbb{Z}_p$, то есть функцию $f: \{0\ldots p-1\}^n \longrightarrow \{0 \ldots p-1\}$ такую, что она линейна по каждому аргументу (по модулю $p$) и на $\{0, 1\}^n$ совпадает с $g$.

        Рассмотрим также функцию $\widetilde{h}: \{0, 1\}^n \longrightarrow \{0\ldots p-1\}$, сопоставляющую номеру шага вычисления номер правила перехода, которое используется на этом шаге в выбранной ветви вычислений. Аналогично тому, как определена функция $f$, введем функцию $h$ как мультилинейное продолжение $\widetilde{h}$ на $\mathbb{Z}_p$.

        В начале алгоритма верификатор спрашивает у $P_1$, принимает ли $M$ вход $x$. Если прувер $P_1$ отвечает отрицательно, то алгоритм завершается и назначаются платежи $(0, 0)$.
        В противном случае верификатор выбирает случайные $a$ и $b \in \mathbb{Z}_p$ и передает их $P_1$. Первый прувер должен ответить коэффициентами многочлена $F(x) = h_1(ax + b)$, где $h_1$ означает функцию $h$ по мнению $P_1$. Верификатор выбирает случайную точку $c_1 = a t_1 + b$ и посылает ее $P_2$, который должен ответить значением $y = h_2(c_1)$. Верификатор проверяет $F(t_1) = y$. В случае, если равенство не соблюдается (пруверы не согласны относительно выбора ветви), игра заканчивается и назначаются платежи $(-1, -2)$.

        Если же равенство выполняется, верификатор проводит бинарный поиск по строкам протокола следующим образом. На каждом шаге он поддерживает максимальный номер $G$ <<хорошей>> строки (то есть той, про состояние машины в которой пруверы $P_1$ и $P_2$ согласны) и минимальный номер $B$ <<плохой>> строки (о состоянии в которой пруверы не согласны). Изначально $G=1$ и $B=2^n$.

        На каждом шаге бинарного поиска прувер выбирает номер строки $k = \left[\frac{G + B}{2}\right]$, которую он собирается проверить, и отсылает его пруверам. Прувер $P_1$ отсылает верификатору коэффициенты многочлена $F_k$, который является сужением функции $f^1_k$ --- состояния машины в строке $k$ по версии $P_1$ --- на прямую $L$ (то есть $F_k(x) = f^1_k(ax + b)$). Прувер $P_2$ отсылает верификатору $y_k = f^2_k(c_1)$.

        Верификатор проверяет правда ли, что $y_k = F_k(t_1)$. Если равенство выполняется, то с большой вероятностью $f^1_k \equiv f^2_k$ и верификатор устанавливает $G = k$, иначе он устанавливает $B = k$. Затем производится следующий шаг бинарного поиска.

        Бинарный поиск заканчивается в тот момент, когда $B = G + 1$, то есть найдены две соседних строки таких, что про состояние в первой из них пруверы согласны, а про состояние в следующей не согласны. Верификатор проводит проверку того, кто из пруверов лжет, следующим образом. 

        Сначала верификатор запрашивает у пруверов, какое правило перехода использовалось в переходе от строки $G$ к строке $B$. Если версии пруверов различаются, то нужно определить,
        кто из них отклонился от выбранной в начале алгоритма ветви, то есть чья версия относительно использованного правила перехода не соответствует значению функции $h$ в точке $G$ --- использованному на шаге $G$ правило перехода. Для этого верификатор выбирает случайную точку $C$ на прямой $a x + b$ и передает пруверу  $P_2$ коэффициенты прямой $L_2 = a'x + b'$, проходящей через точки $C$ и $G$. Прувер $P_2$ отвечает коэффициентами многочлена $F'(x) = h_2(a'x + b')$. Верификатор проверяет, что значение $F'$ в точке, соответствующей точке $G$, совпадает с версией $P_2$ относительно правила перехода, то есть показания $P_2$ согласуются друг с другом, а затем, что совпадают значения $F$ и $F'$ в точках, соответствующих $C$. Если они не совпадают, то второй прувер лжет и назначаются платежи $(3, -3)$, иначе получается, что $P_2$ ответил верно и лжет $P_1$, поэтому назначаются платежи $(-3, 3)$.

        Остается разобрать случай, когда пруверы согласны относительно того, какое правило перехода использовалось. Заметим, что при переходе от строки $G$ к строке $B$ значение функции $f$ поменялось не более, чем в двух точках: могло поменяться состояние той ячейки, где находилась считывающая головка, и той ячейки, куда она передвинулась. Верификатор запрашивает у $P_1$ и $P_2$ информацию о том, какие ячейки по их версии поменялись при переходе. А затем запрашивает у них версии о состояниях всех ячеек, которые могли поменяться (всего не более четырех ячеек), в строке $G$.

        Если пруверы сообщили одинаковые версии о состоянии активных ячеек, то верификатор может посчитать разность $f_B - f_G$ (она зависит только от состояний изменившихся ячеек) и сверить ее с $F_B - F_G$ и $y_B - y_G$. Таким образом выясняется, кто из пруверов лжет. Если соврал $P_1$, то назначаются награды $(-1, 1)$, иначе --- $(1, -1)$.

        Иначе существует ячейка $c$, про состояние которой пруверы не согласны. Обозначим $s_1$ и $s_2$ --- состояние этой ячейки по версии $P_1$ и $P_2$ соответственно. Верификатору нужно сверить состояние этой ячейки с теми данными, которые пруверы сообщали ранее ($F_G$ и $y_G$). Для этого он действует аналогично процедуре, описанной выше: выбирает случайную точку $c_2$ на прямой $L$ и передает пруверу $P_2$ коэффициенты прямой $L_2 = a'x + b'$, проходящей через точки $c$ и $c_2$. Прувер $P_2$ отвечает коэффициентами многочлена $F'(x) = f^2_G(a'x + b')$. Верификатор проверяет, что значение $F'$ в точке, соответствующей точке $c$, совпадает с $s_2$, то есть показания $P_2$ согласуются друг с другом, а затем, что совпадают значения $F_G$ и $F'$ в точках, соответствующих $c_2$. Если они не совпадают, то второй прувер лжет и назначаются платежи $(1, -1)$, иначе получается, что $P_2$ ответил верно и лжет $P_1$, поэтому назначаются платежи $(-1, 1)$.

        \section{Доказательство корректности}
        \begin{theorem}Определенная выше система рациональных интерактивных доказательств с коммуницирующими пруверами удовлетворяет условиям из определения $\textbf{comm-ncRIP}$ для языка, задаваемого машиной Тьюринга из определения алгоритма.\end{theorem}
        \begin{proof}Требуется показать, что в описанной игре существует рекурсивно-максимальное УСР и при любом рекурсивно-максимальном УСР верификатор получает правильный ответ.

            Для начала сделаем замечание, упрощающее анализ равновесия. Вера игрока задает вероятностное распределение на каждом информационном множестве, то есть, менее формально, задает представление игрока о неизвестных ему элементах состояния игры. В исследуемой игре это сообщения, которыми верификатор обменивался с другим прувером. Информация, содержащаяся в них сводится к знанию чисел $a, b, c_1$ и функций $h_1$, $h_2$, $f^1_k$, $f^2_k$. Как будет показано ниже, в равновесном профиле $h_1 = h_2$, так что эта часть известна достоверно. Также можно заметить, что знание функций $f^i_k$ не влияет на выбор стратегии. Веру относительно чисел $a, b, y$ прувер может строить только исходя из хода игры в силу того, что, как будет показано ниже, передача этих чисел сопернику ухудшает положение игрока. Заметим, что на каждом шаге бинарного поиска, прувер получает в худшем случае не более бита информации из того факта, оказалась ли выбранная строка хорошей или плохой. Таким образом, в течении игры игроки не могут получить достаточное количество информации, чтобы иметь веру относительно $a, b, c_1$, влияющую на ожидаемую полезность. Приведенные рассуждения показывают, что веры игроков не влияют на ожидаемую награду при фиксированном стратегическом профиле и, поэтому, могут быть исключены из дальнейших рассуждений.

        Проведем доказательство, проанализировав стратегический профиль исходя из предположения, что он является рекурсивно-максимальным УСР, и параллельно строя пример такого профиля. Будем считать, что число $p$ достаточно велико для того, чтобы изменение ожидаемого выигрыша от учета случаев, когда один из пруверов случайно угадывает верный ответ, было меньше $1$.

        Пусть $x \in L$, тогда $P_1$ на первом шаге алгоритма соглашается продолжать и передает верификатору полином $F$. Второй прувер должен передать верификатору значение $y$. Для этого ему необходимо получить от $P_1$ либо совпадающую с первым прувером функцию $h$, либо прямую $a x + b$ и полином $F$, либо значение $F(t)$. В случае, если $P_2$ соглашается на то, чтобы получить от оппонента только необходимое ему значение $F(t)$, то в дальнейшем он не сможет пройти проверку корректности перехода и получит полезность $-3$. Передать прямую и полином невыгодно первому пруверу, так как это позволит $P_2$ гарантированно подделать проверку перехода (так как он будет знать, с чем будут сравниваться его ответы), что повлечет за собой $-3$ полезности для первого прувера.

        Таким образом, остается лишь вариант, когда пруверы получают общую функцию $h$ в результате первичной фазы алгоритма. Также заметим, что при наличии ветви, принимающей вход, выбрана будет она, так как угроза $P_2$ выбрать другую ветвь неправдоподобна --- первый прувер ничего не потеряет, а сам $P_2$ получит $-2$ вместо $-1$.

        После первой фазы алгоритма игра идет с нулевой суммой, что означает, что коммуникация не может быть выгодна пруверам, так что ее можно не рассматривать. В процессе бинарного поиска игроки будут придерживаться одной ветви --- так как отклонение от функции $h$ грозит штрафом в $-3$. В результате будут выбраны строки $G$ и $B$ и проверка завершится в пользу $P_1$, так как он предлагает корректный протокол вычисления по ветви, заданной функцией $h$. Таким образом, при следовании данному профилю $P_1$ получает награду $1$, что означает, что его выбор на первом шаге был оптимальным.

        В случае, если $x \notin L$ аналогичными рассуждениями убеждаемся в том, что $P_1$ в основной ветви алгоритма может рассчитывать лишь на награду в $-1$, что означает, что ему выгоднее спасовать.

        Заметим, что результат работы алгоритма зависит лишь от того, спасовал ли $P_1$ на первом шаге. Как показано выше, в случае, если он отклоняется от равновесия на этом шаге, то теряет в полезности на величину, не зависящую от длины входа. Таким образом, предложенный алгоритм обладает константным зазором полезности.
    \end{proof}
        \section{Расширение на большие классы языков}
        В предыдущих разделах был предложен алгоритм доказательства в классе $\textbf{comm-ncRIP}$ с константным зазором полезности для произвольного языка класса $\textbf{NEXP}$. На его основе можно построить системы доказательств более широких классов аналогично тому, как это сделано в работе Chen et al.~\cite{chen2017noncoop} для класса $\textbf{ncRIP}$. Приводимый алгоритм взят из указанной статьи практически без изменений.

        \begin{theorem}Любой язык $L \in \textbf{P}^{\textbf{NEXP}\left[\alpha(n)\right]}$ (класс языков, вычислимых за полиномиальное время на детерминированной машине Тьюринга с $\alpha(n)$ запросами к оракулу $\textbf{NEXP}$) позволяет рациональное интерактивное доказательство с взаимодействующими пруверами с зазором полезности, пропорциональным $\frac{1}{\alpha(n)}$.\end{theorem}

            \begin{proof}
                Рассмотрим следующий протокол с тремя пруверами ($P_1$, $P_2$ и $P_3$).
                \begin{enumerate}
                    \item Прувер $P_1$ отсылает верификатору биты $c$, $c_1$, \ldots, $c_{\alpha(n)}$.
                    \item Верификатор симулирует машину Тьюринга, соответствующую языку $L$, используя биты $c_1$, \ldots, $c_{\alpha(n)}$ в качестве ответов оракула. Если машина Тьюринга остановилась в принимающем состоянии, а $c = 0$, или, наоборот, машина отвергла вход, а $c = 1$, алгоритм прерывается и назначаются платежи $(-1, 0, 0)$.
                    \item Верификатор выбирает случайное $k \in \set{1\ldots\alpha(n)}$ и запускает алгоритм для класса $\textbf{NEXP}$ для проверки правильности $k$-го запроса к оракулу с помощью пруверов $P_2$ и $P_3$.
                    \item Пруверы $P_2$ и $P_3$ получают награду согласно алгоритму для $\textbf{NEXP}$. Первый прувер получает $1$, если полученный ответ совпадает с $c_k$ и $0$ в противном случае.
                \end{enumerate}
                Заметим, что первому пруверу бесполезно общаться с остальными, так что корректность этого алгоритма непосредственно следует из корректности алгоритма для класса $\textbf{NEXP}$ и корректности аналогичного алгоритма для класса $\textbf{ncRIP}$.
            \end{proof}
            Таким образом мы получаем, что система доказательств со взаимодействующими пруверами обладает не меньшей вычислительной силой, чем с невзаимодействующими.
            \begin{corollary}
                $O\left(\alpha(n)\right)-\textbf{ncRIP} \subseteq O\left(\alpha(n)\right)-\textbf{comm-ncRIP}$.
            \end{corollary}
            \section{Верхняя оценка}
            Покажем теперь, что выполнено вложение в обратную сторону, то есть верна следующая теорема.
            \begin{theorem}
                $O\left(\alpha(n)\right)-\textbf{comm-ncRIP} \subseteq O\left(\alpha(n)\right)-\textbf{ncRIP}$.
            \end{theorem}
            \begin{proof}
                Пусть дан произвольный протокол с коммуницирующими пруверами. Рассмотрим сообщения, которыми они обмениваются. Так как в рассматриваемой модели пруверы детерминированные и выбирают свои стратегии до начала игры, передаваемые сообщения зависят только от случайных бит верификатора, которых не более чем полиномиальное число. Таким образом, сообщения пруверов могут быть всегда сжаты до полиномиального размера.

                Получается, что протокол с взаимодействующими пруверами можно свести к протоколу с невзаимодействующими пруверами, сделав так, что пруверы вместо прямой передачи сообщений, делают это через верификатора. В силу того, что сообщения не более чем полиномиальной длины, это не повлияет на полиномиальность верификатора. С точки зрения пруверов игра не изменится, то есть равновесия останутся прежними и построенный протокол будет корректен
            \end{proof}
            Из доказанного можно окончательно получить следующее
            \begin{corollary}
                $O\left(\alpha(n)\right)-\textbf{comm-ncRIP} = O\left(\alpha(n)\right)-\textbf{ncRIP}$
            \end{corollary}
            \chapter*{Заключение}
            В данной работе были изучены рациональные интерактивные доказательства и сделан обзор некоторых существующих результатов по этой теме. Также был предложен новый класс рациональных интерактивных доказательств с коммуницирующими пруверами $\textbf{comm-ncRIP}$ и доказано, что он совпадает с классом доказательств с некоммуницирующими пруверами. Данный результат представляет как теоретический интерес, так и новые возможности для приложений в силу того, что требовавшееся ранее условие невзаимодействие сложно реализуемо на практике в случае, если пруверы неподконтрольны верификатору и подключены к глобальной сети. Следует отметить, что в предложенном протоколе, хотя взаимодействие и разрешено, существует равновесный профиль стратегий, не включающий обмен сообщениями. Таким образом, данный протокол применим также и к классу $\textbf{ncRIP}$, причем он является технически более простым, чем предложенный ранее.

            В дальнейшей работе по этой теме может быть рассмотрен вопрос того, как изменится класс $\textbf{comm-ncRIP}$, если разрешить случайные биты пруверов, то есть перейти к поведенческим стратегиям.
\newpage
\printbibliography
\end{document}
